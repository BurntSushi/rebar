rebar
=====
A biased barometer for gauging the relative speed of some regex engines on a
curated set of tasks.

## Results

This section shows the results of a _curated and [biased](BIAS.md)_ set of
benchmarks. These reflect only a small subset of the benchmarks defined in
this repository, but were carefully crafted to attempt to represent a broad
range of use cases and annotated where possible with analysis to aide in the
interpretation of results.

The results begin with a summary, then a list of links to each benchmark group
and then finally the results for each group. Results are shown one benchmark
group at a time, where a single group is meant to combine related regexes or
workloads, where it is intended to be useful to see how results change across
regex engines. Analysis is provided, at minimum, for every group. Although,
analysis is heavily biased towards Rust's regex crate, as it is what this
author knows best. However, contributions that discuss other regex engines are
very welcomed.

Below each group of results are the parameters for each individual benchmark
within that group. An individual benchmark may contain some analysis specific
to it, but it will at least contain a summary of the benchmark details. Some
parameters, such as the haystack, are usually too big to show in this README.
One can use rebar to look at the haystack directly. Just take the `full name`
of the benchmark and give it to the `rebar haystack` command. For example:

```
$ rebar haystack unicode/compile/fifty-letters
ͱͳͷΐάέήίΰαβγδεζηθικλμνξοπρςστυφχψωϊϋόύώϙϛϝϟϡϸϻͱͳͷΐάέή
```

Similarly, the full benchmark execution details (including the haystack) can
be seen with the `rebar klv` command:

```
$ rebar klv unicode/compile/fifty-letters
name:29:unicode/compile/fifty-letters
model:7:compile
pattern:7:\pL{50}
case-insensitive:5:false
unicode:4:true
haystack:106:ͱͳͷΐάέήίΰαβγδεζηθικλμνξοπρςστυφχψωϊϋόύώϙϛϝϟϡϸϻͱͳͷΐάέή
max-iters:1:0
max-warmup-iters:1:0
max-time:1:0
max-warmup-time:1:0
```

Finally, you can run the benchmark yourself and look at results on the command
line:

```
$ rebar measure -f '^unicode/compile/fifty-letters$' | tee results.csv
$ rebar cmp results.csv
```

<!-- BEGIN: report -->
<!-- Auto-generated by rebar, do not edit manually! -->
<!-- Generated with command: -->
<!-- rebar report tmp/base/2023-03-25.1/dotnet-compiled.csv tmp/base/2023-03-25.1/dotnet.csv tmp/base/2023-03-25.1/dotnet-nobacktrack.csv tmp/base/2023-03-25.1/go-regexp.csv tmp/base/2023-03-25.1/hyperscan.csv tmp/base/2023-03-25.1/pcre2.csv tmp/base/2023-03-25.1/pcre2-jit.csv tmp/base/2023-03-25.1/python-re.csv tmp/base/2023-03-25.1/python-regex.csv tmp/base/2023-03-25.1/re2.csv tmp/base/2023-03-25.1/regress.csv tmp/base/2023-03-25.1/rust-aho-corasick-dfa.csv tmp/base/2023-03-25.1/rust-aho-corasick-nfa.csv tmp/base/2023-03-25.1/rust-memchr-memmem.csv tmp/base/2023-03-25.1/rust-regex-ast.csv tmp/base/2023-03-25.1/rust-regex-backtrack.csv tmp/base/2023-03-25.1/rust-regex.csv tmp/base/2023-03-25.1/rust-regex-dense.csv tmp/base/2023-03-25.1/rust-regex-hir.csv tmp/base/2023-03-25.1/rust-regex-hybrid.csv tmp/base/2023-03-25.1/rust-regex-meta.csv tmp/base/2023-03-25.1/rust-regex-nfa.csv tmp/base/2023-03-25.1/rust-regexold.csv tmp/base/2023-03-25.1/rust-regex-onepass.csv tmp/base/2023-03-25.1/rust-regex-pikevm.csv tmp/base/2023-03-25.1/rust-regex-sparse.csv tmp/base/2023-03-26.2/^perl$.csv --splice README.md --statistic median --units throughput -->
### Summary

Below are two tables summarizing the results of regex engines benchmarked.
Each regex engine includes its version at the time measurements were captured,
a summary score that ranks it relative to other regex engines across all
benchmarks and the total number of measurements collected.

The first table ranks regex engines based on search time. The second table
ranks regex engines based on compile time.

The summary statistic used is the [geometric mean] of the speed ratios for
each regex engine across all benchmarks that include it. The ratios within
each benchmark are computed from the median of all timing samples taken, and
dividing it by the best median of the regex engines that participated in the
benchmark. For example, given two regex engines `A` and `B` with results `35
ns` and `25 ns` on a single benchmark, `A` has a speed ratio of `1.4` and
`B` has a speed ratio of `1.0`. The geometric mean reported here is then the
"average" speed ratio for that regex engine across all benchmarks.

Each regex engine is linked to the directory containing the runner program
responsible for compiling a regex, using it in a search and reporting timing
results. Each directory contains a `README` file briefly describing any engine
specific details for the runner program.

Each regex engine is also defined in
[benchmarks/engines.toml](benchmarks/engines.toml), using the same name listed
in the table below. Each definition includes instructions for how to run,
build, clean and obtain the version of each regex engine.

**Caution**: Using a single number to describe the overall performance of a
regex engine is a fraught endeavor, and it is debatable whether it should be
included here at all. It is included primarily because the number of benchmarks
is quite large and overwhelming. It can be quite difficult to get a general
sense of things without a summary statistic. In particular, a summary statistic
is also useful to observe how the _overall picture_ itself changes as changes
are made to the barometer. (Whether it be by adding new regex engines or
adding/removing/changing existing benchmarks.) One particular word of caution
is that while geometric mean is more robust with respect to outliers than
arithmetic mean, it is not unaffected by them. Therefore, it is still critical
to examine individual benchmarks if one wants to better understanding the
performance profile of any specific regex engine or workload.

[geometric mean]: https://dl.acm.org/doi/pdf/10.1145/5666.5673

#### Summary of search-time benchmarks

| Engine | Version | Geometric mean of speed ratios | Benchmark count |
| ------ | ------- | ------------------------------ | --------------- |
| [rust/aho-corasick/dfa](engines/rust/aho-corasick) | 0.7.20 | 1.00 | 5 |
| [rust/regex/ast](engines/rust/regex-syntax) | 0.6.28 | 1.00 | 0 |
| [rust/regex/hir](engines/rust/regex-syntax) | 0.6.28 | 1.00 | 0 |
| [rust/regex/nfa](engines/rust/regex-automata) | 0.2.0 | 1.00 | 0 |
| [rust/memchr/memmem](engines/rust/memchr) | 2.5.0 | 1.12 | 10 |
| [rust/regex/onepass](engines/rust/regex-automata) | 0.2.0 | 1.18 | 5 |
| [rust/regex/dense](engines/rust/regex-automata) | 0.2.0 | 1.35 | 5 |
| [rust/regex/meta](engines/rust/regex-automata) | 0.2.0 | 1.63 | 239 |
| [hyperscan](engines/hyperscan) | 5.4.1 2023-02-22 | 1.92 | 49 |
| [rust/aho-corasick/nfa](engines/rust/aho-corasick) | 0.7.20 | 2.05 | 5 |
| [rust/regex/backtrack](engines/rust/regex-automata) | 0.2.0 | 2.34 | 7 |
| [rust/regexold](engines/rust/regex-old) | 1.7.1 | 2.78 | 173 |
| [rust/regex](engines/rust/regex) | 1.7.1 | 3.29 | 68 |
| [pcre2/jit](engines/pcre2) | 10.42 2022-12-11 | 3.78 | 200 |
| [dotnet/compiled](engines/dotnet) | 7.0.3 | 4.36 | 30 |
| [re2](engines/re2) | 2023-03-01 | 6.73 | 196 |
| [rust/regex/hybrid](engines/rust/regex-automata) | 0.2.0 | 7.31 | 19 |
| [dotnet/nobacktrack](engines/dotnet) | 7.0.3 | 8.28 | 27 |
| [dotnet](engines/dotnet) | 7.0.3 | 18.79 | 1 |
| [regress](engines/regress) | 0.5.0 | 27.15 | 134 |
| [python/regex](engines/python) | 2022.10.31 | 31.18 | 178 |
| [pcre2](engines/pcre2) | 10.42 2022-12-11 | 40.14 | 144 |
| [perl](engines/perl) | 5.36.0 | 40.25 | 30 |
| [rust/regex/pikevm](engines/rust/regex-automata) | 0.2.0 | 42.76 | 11 |
| [python/re](engines/python) | 3.10.9 | 58.74 | 153 |
| [go/regexp](engines/go) | 1.20.1 | 66.38 | 188 |

#### Summary of compile-time benchmarks

| Engine | Version | Geometric mean of speed ratios | Benchmark count |
| ------ | ------- | ------------------------------ | --------------- |
| [dotnet](engines/dotnet) | 7.0.3 | 1.00 | 0 |
| [pcre2](engines/pcre2) | 10.42 2022-12-11 | 1.00 | 11 |
| [perl](engines/perl) | 5.36.0 | 1.00 | 0 |
| [rust/aho-corasick/nfa](engines/rust/aho-corasick) | 0.7.20 | 1.00 | 3 |
| [rust/memchr/memmem](engines/rust/memchr) | 2.5.0 | 1.00 | 0 |
| [rust/regex/backtrack](engines/rust/regex-automata) | 0.2.0 | 1.00 | 0 |
| [rust/regex/hybrid](engines/rust/regex-automata) | 0.2.0 | 1.00 | 0 |
| [rust/regex/onepass](engines/rust/regex-automata) | 0.2.0 | 1.00 | 0 |
| [rust/regex/pikevm](engines/rust/regex-automata) | 0.2.0 | 1.00 | 0 |
| [rust/regex/hir](engines/rust/regex-syntax) | 0.6.28 | 1.11 | 9 |
| [rust/regex/ast](engines/rust/regex-syntax) | 0.6.28 | 1.23 | 6 |
| [regress](engines/regress) | 0.5.0 | 3.40 | 8 |
| [pcre2/jit](engines/pcre2) | 10.42 2022-12-11 | 3.45 | 18 |
| [go/regexp](engines/go) | 1.20.1 | 6.98 | 19 |
| [rust/regex/nfa](engines/rust/regex-automata) | 0.2.0 | 7.62 | 12 |
| [rust/aho-corasick/dfa](engines/rust/aho-corasick) | 0.7.20 | 8.32 | 3 |
| [re2](engines/re2) | 2023-03-01 | 12.74 | 19 |
| [dotnet/compiled](engines/dotnet) | 7.0.3 | 13.64 | 8 |
| [rust/regex](engines/rust/regex) | 1.7.1 | 13.70 | 9 |
| [rust/regexold](engines/rust/regex-old) | 1.7.1 | 16.06 | 21 |
| [rust/regex/meta](engines/rust/regex-automata) | 0.2.0 | 22.05 | 22 |
| [python/re](engines/python) | 3.10.9 | 29.59 | 12 |
| [dotnet/nobacktrack](engines/dotnet) | 7.0.3 | 55.20 | 5 |
| [python/regex](engines/python) | 2022.10.31 | 63.42 | 18 |
| [hyperscan](engines/hyperscan) | 5.4.1 2023-02-22 | 1187.50 | 10 |
| [rust/regex/dense](engines/rust/regex-automata) | 0.2.0 | 3866.79 | 4 |

### Benchmark Groups

Below is a list of links to each benchmark group in this particular barometer.
Each benchmark group contains 1 or more related benchmarks. The idea of each
group is to tell some kind of story about related workloads, and to give
a sense of how performance changes based on the variations between each
benchmark.

* [aho-corasick](#aho-corasick)
  * [compile](#compile)
  * [dictionary](#dictionary)
* [captures](#captures)
* [curated](#curated)
  * [literal](#literal)
  * [literal-alternate](#literal-alternate)
  * [date](#date)
  * [ruff-noqa](#ruff-noqa)
  * [lexer-veryl](#lexer-veryl)
  * [cloud-flare-redos](#cloud-flare-redos)
  * [unicode-character-data](#unicode-character-data)
  * [words](#words)
  * [aws-keys](#aws-keys)
  * [bounded-repeat](#bounded-repeat)
  * [unstructured-to-json](#unstructured-to-json)
* [dictionary](#dictionary)
  * [compile](#compile)
  * [search](#search)
* [folly](#folly)
* [grep](#grep)
* [hyperscan](#hyperscan)
* [imported](#imported)
  * [leipzig](#leipzig)
  * [lh3lh3-reb](#lh3lh3-reb)
  * [mariomka](#mariomka)
  * [regex-redux](#regex-redux)
  * [rsc](#rsc)
  * [sherlock](#sherlock)
* [opt](#opt)
  * [accelerate](#accelerate)
  * [backtrack](#backtrack)
  * [fixed-length](#fixed-length)
  * [literal-alt](#literal-alt)
  * [onepass](#onepass)
  * [prefilter](#prefilter)
  * [reverse-anchored](#reverse-anchored)
  * [reverse-inner](#reverse-inner)
  * [reverse-suffix](#reverse-suffix)
* [reported](#reported)
  * [i787-keywords](#i787-keywords)
  * [p893-hir-case-folding](#p893-hir-case-folding)
* [scratch](#scratch)
* [slow](#slow)
* [unicode](#unicode)
  * [codepoints](#codepoints)
  * [compile](#compile)
  * [overlapping-words](#overlapping-words)
  * [word](#word)
* [wild](#wild)
  * [bibleref](#bibleref)
  * [caddy](#caddy)
  * [dot-star-capture](#dot-star-capture)
  * [grapheme](#grapheme)
  * [parol-veryl](#parol-veryl)
  * [ruff](#ruff)
  * [rustsec-cargo-audit](#rustsec-cargo-audit)
  * [url](#url)

### aho-corasick

#### compile

| Engine | dictionary-english | dictionary-english-10 | dictionary-english-15 |
| - | - | - | - |
| rust/aho-corasick/dfa | 120.92ms | 188.38ms | 16.59ms |
| rust/aho-corasick/nfa | **32.37ms** | **13.25ms** | **1.53ms** |

<details>
<summary>Show individual benchmark parameters.</summary>

**dictionary-english**

| Parameter | Value |
| --------- | ----- |
| full name | `aho-corasick/compile/dictionary-english` |
| model | [`compile`](MODELS.md#compile) |
| regex-path | [`dictionary/english/sorted-by-length.txt`](benchmarks/regexes/dictionary/english/sorted-by-length.txt) |
| case-insensitive | `false` |
| unicode | `false` |
| haystack | `zygotes` |
| count | 1 |


**dictionary-english-10**

| Parameter | Value |
| --------- | ----- |
| full name | `aho-corasick/compile/dictionary-english-10` |
| model | [`compile`](MODELS.md#compile) |
| regex-path | [`dictionary/english/length-10.txt`](benchmarks/regexes/dictionary/english/length-10.txt) |
| case-insensitive | `false` |
| unicode | `false` |
| haystack | `Zubeneschamali's` |
| count | 1 |


**dictionary-english-15**

| Parameter | Value |
| --------- | ----- |
| full name | `aho-corasick/compile/dictionary-english-15` |
| model | [`compile`](MODELS.md#compile) |
| regex-path | [`dictionary/english/length-15.txt`](benchmarks/regexes/dictionary/english/length-15.txt) |
| case-insensitive | `false` |
| unicode | `false` |
| haystack | `Zubeneschamali's` |
| count | 1 |


</details>

#### dictionary

| Engine | english | english-tiny | english-10 | english-15 | i787-noword |
| - | - | - | - | - | - |
| rust/aho-corasick/dfa | **158.8 MB/s** | **500.0 MB/s** | **504.5 MB/s** | **707.5 MB/s** | **597.9 MB/s** |
| rust/aho-corasick/nfa | 134.5 MB/s | 349.1 MB/s | 179.5 MB/s | 188.2 MB/s | 292.2 MB/s |

<details>
<summary>Show individual benchmark parameters.</summary>

**english**

| Parameter | Value |
| --------- | ----- |
| full name | `aho-corasick/dictionary/english` |
| model | [`count`](MODELS.md#count) |
| regex-path | [`dictionary/english/sorted-by-length.txt`](benchmarks/regexes/dictionary/english/sorted-by-length.txt) |
| case-insensitive | `false` |
| unicode | `false` |
| haystack-path | [`opensubtitles/en-medium.txt`](benchmarks/haystacks/opensubtitles/en-medium.txt) |
| count | 15032 |


**english-tiny**

| Parameter | Value |
| --------- | ----- |
| full name | `aho-corasick/dictionary/english-tiny` |
| model | [`count`](MODELS.md#count) |
| regex-path | [`dictionary/english/sorted-by-length.txt`](benchmarks/regexes/dictionary/english/sorted-by-length.txt) |
| case-insensitive | `false` |
| unicode | `false` |
| haystack-path | [`opensubtitles/en-tiny.txt`](benchmarks/haystacks/opensubtitles/en-tiny.txt) |
| count | 22 |


**english-10**

| Parameter | Value |
| --------- | ----- |
| full name | `aho-corasick/dictionary/english-10` |
| model | [`count`](MODELS.md#count) |
| regex-path | [`dictionary/english/length-10.txt`](benchmarks/regexes/dictionary/english/length-10.txt) |
| case-insensitive | `false` |
| unicode | `false` |
| haystack-path | [`opensubtitles/en-medium.txt`](benchmarks/haystacks/opensubtitles/en-medium.txt) |
| count | 66 |


**english-15**

| Parameter | Value |
| --------- | ----- |
| full name | `aho-corasick/dictionary/english-15` |
| model | [`count`](MODELS.md#count) |
| regex-path | [`dictionary/english/length-15.txt`](benchmarks/regexes/dictionary/english/length-15.txt) |
| case-insensitive | `false` |
| unicode | `false` |
| haystack-path | [`opensubtitles/en-medium.txt`](benchmarks/haystacks/opensubtitles/en-medium.txt) |
| count | 1 |


**i787-noword**

| Parameter | Value |
| --------- | ----- |
| full name | `aho-corasick/dictionary/i787-noword` |
| model | [`count`](MODELS.md#count) |
| regex-path | [`reported/i787-keywords.txt`](benchmarks/regexes/reported/i787-keywords.txt) |
| case-insensitive | `false` |
| unicode | `false` |
| haystack-path | [`github-rustlang-regex-i787.txt`](benchmarks/haystacks/github-rustlang-regex-i787.txt) |
| count | 4861 |


</details>

### captures

| Engine | contiguous-letters |
| - | - |
| go/regexp | 1088.9 KB/s |
| pcre2/jit | **21.1 MB/s** |
| python/re | 1840.9 KB/s |
| re2 | 5.5 MB/s |
| regress | 14.5 MB/s |
| rust/regex/meta | 10.7 MB/s |
| rust/regexold | 1299.2 KB/s |

<details>
<summary>Show individual benchmark parameters.</summary>

**contiguous-letters**

| Parameter | Value |
| --------- | ----- |
| full name | `captures/contiguous-letters` |
| model | [`count-captures`](MODELS.md#count-captures) |
| regex | `````(?:(a+)\|(b+)\|(c+)\|(d+)\|(e+)\|(f+)\|(g+)\|(h+)\|(i+)\|(j+)\|(k+)\|(l+)\|(m+)\|(n+)\|(o+)\|(p+)\|(q+)\|(r+)\|(s+)\|(t+)\|(u+)\|(v+)\|(w+)\|(x+)\|(y+)\|(z+))````` |
| case-insensitive | `false` |
| unicode | `false` |
| haystack-path | [`opensubtitles/en-medium.txt`](benchmarks/haystacks/opensubtitles/en-medium.txt) |
| count | 81494 |


</details>

### curated

#### literal

This group of benchmarks measures regex patterns that are simple literals. When
possible, we also measure case insensitive versions of the same pattern. We do
this across three languages: English, Russian and Chinese. For English, Unicode
mode is disabled while it is enabled for Russian and Chinese. (Which mostly
only matters for the case insensitive benchmarks.)

This group is mainly meant to demonstrate two things. Firstly is whether the
regex engine does some of the most basic forms of optimization by recognizing
that a pattern is just a literal, and that a full blown regex engine is
probably not needed. Indeed, naively using a regex engine for this case is
likely to produce measurements much worse than most regex engines. Secondly is
how the performance of simple literal searches changes with respect to both
case insensitivity and Unicode. Namely, substring search algorithms that work
well on ASCII text don't necessarily also work well on UTF-8 that contains many
non-ASCII codepoints. This is especially true for case insensitive searches.

Notice, for example, how RE2 seems to be faster in the `sherlock-casei-ru`
benchmark than in the `sherlock-ru` benchmark, even though the latter is "just"
a simple substring search where as the former is a multiple substring search.
In the case of `sherlock-ru`, RE2 actually attempts a literal optimization that
likely gets caught up in dealing with a high false positive rate of candidates.
Where as in the case of `sherlock-casei-ru`, no literal optimization is
attempted and instead its lazy DFA is used. The high false positive rate in the
simpler literal case winds up making it overall slower than it likely would be
if it would just use the DFA.

This is not in any way to pick on RE2. Every regex engine that does literal
optimizations (and most do) will suffer from this kind of setback in one way
or another.

| Engine | sherlock-en | sherlock-casei-en | sherlock-ru | sherlock-casei-ru | sherlock-zh |
| - | - | - | - | - | - |
| dotnet/compiled | 12.5 GB/s | 6.0 GB/s | 17.5 GB/s | 5.1 GB/s | 34.3 GB/s |
| dotnet/nobacktrack | 8.2 GB/s | 4.0 GB/s | 7.1 GB/s | 2.5 GB/s | 28.5 GB/s |
| go/regexp | 3.9 GB/s | 43.2 MB/s | 2.1 GB/s | 32.6 MB/s | 2036.6 MB/s |
| hyperscan | **33.7 GB/s** | **30.5 GB/s** | 4.4 GB/s | 7.3 GB/s | **50.3 GB/s** |
| pcre2 | 7.2 GB/s | 969.9 MB/s | 2.1 MB/s | 2044.5 KB/s | 57.9 MB/s |
| pcre2/jit | 24.9 GB/s | 16.6 GB/s | 31.9 GB/s | **18.8 GB/s** | 37.1 GB/s |
| perl | 2.8 GB/s | 556.9 MB/s | 3.3 GB/s | 98.3 MB/s | 7.7 GB/s |
| python/re | 3.7 GB/s | 295.7 MB/s | 6.7 GB/s | 455.3 MB/s | 11.2 GB/s |
| python/regex | 3.6 GB/s | 2.8 GB/s | 4.6 GB/s | 4.1 GB/s | 6.8 GB/s |
| re2 | 10.6 GB/s | 2.5 GB/s | 764.2 MB/s | 942.0 MB/s | 2.7 GB/s |
| regress | 3.5 GB/s | 1189.8 MB/s | 3.6 GB/s | 314.0 MB/s | 3.6 GB/s |
| rust/regex | 32.2 GB/s | 8.8 GB/s | **32.4 GB/s** | 5.8 GB/s | 39.7 GB/s |
| rust/regex/meta | 28.6 GB/s | 10.7 GB/s | 32.3 GB/s | 9.1 GB/s | 37.5 GB/s |
| rust/regexold | 32.5 GB/s | 8.5 GB/s | 31.3 GB/s | 6.8 GB/s | 39.5 GB/s |

<details>
<summary>Show individual benchmark parameters.</summary>

**sherlock-en**

| Parameter | Value |
| --------- | ----- |
| full name | `curated/01-literal/sherlock-en` |
| model | [`count`](MODELS.md#count) |
| regex | `````Sherlock Holmes````` |
| case-insensitive | `false` |
| unicode | `false` |
| haystack-path | [`opensubtitles/en-sampled.txt`](benchmarks/haystacks/opensubtitles/en-sampled.txt) |
| count | 513 |


**sherlock-casei-en**

| Parameter | Value |
| --------- | ----- |
| full name | `curated/01-literal/sherlock-casei-en` |
| model | [`count`](MODELS.md#count) |
| regex | `````Sherlock Holmes````` |
| case-insensitive | `true` |
| unicode | `false` |
| haystack-path | [`opensubtitles/en-sampled.txt`](benchmarks/haystacks/opensubtitles/en-sampled.txt) |
| count | 522 |


**sherlock-ru**

| Parameter | Value |
| --------- | ----- |
| full name | `curated/01-literal/sherlock-ru` |
| model | [`count`](MODELS.md#count) |
| regex | `````Шерлок Холмс````` |
| case-insensitive | `false` |
| unicode | `true` |
| haystack-path | [`opensubtitles/ru-sampled.txt`](benchmarks/haystacks/opensubtitles/ru-sampled.txt) |
| count | 724 |


**sherlock-casei-ru**

| Parameter | Value |
| --------- | ----- |
| full name | `curated/01-literal/sherlock-casei-ru` |
| model | [`count`](MODELS.md#count) |
| regex | `````Шерлок Холмс````` |
| case-insensitive | `true` |
| unicode | `true` |
| haystack-path | [`opensubtitles/ru-sampled.txt`](benchmarks/haystacks/opensubtitles/ru-sampled.txt) |
| count | 746 |


**sherlock-zh**

| Parameter | Value |
| --------- | ----- |
| full name | `curated/01-literal/sherlock-zh` |
| model | [`count`](MODELS.md#count) |
| regex | `````夏洛克·福尔摩斯````` |
| case-insensitive | `false` |
| unicode | `true` |
| haystack-path | [`opensubtitles/zh-sampled.txt`](benchmarks/haystacks/opensubtitles/zh-sampled.txt) |
| count | 30 |


</details>

#### literal-alternate

This group is like `literal`, but expands the complexity from a simple literal
to a small alternation of simple literals, including case insensitive variants
where applicable. Once again, we do this across three languages: English,
Russian and Chinese. We disable Unicode mode for English but enable it for
Russian and Chinese. Enabling Unicode here generally only means that case
insensitivity takes Unicode case folding rules into account.

This benchmark ups the ante when it comes to literal optimizations. Namely,
for a regex engine to optimize this case, it generally needs to be capable of
reasoning about literal optimizations that require one or more literals from
a set to match. Many regex engines don't deal with this case well, or at all.
For example, after a quick scan at comparing the `sherlock-en` benchmark here
and in the previous `literal` group, one thing that should stand out is the
proportion of regex engines that now measure throughput in MB/s instead of
GB/s.

One of the difficulties in optimizing for this case is that multiple substring
search is difficult to do in a way that is fast. In particular, this benchmark
carefully selected each alternation literal to start with a different character
than the other alternation literals. This, for example, inhibits clever regex
engines from noticing that all literals begin with the same byte (or small
number of bytes). Consider an alternation like `foo|far|fight`. It is not hard
to see that a regex engine _could_ just scan for the letter `f` as a prefilter
optimization. Here, we pick our regex such that this sort of shortcut isn't
available. For the regex engine to optimize this case, it really needs to deal
with the problem of multiple substring search.

Multiple substring search _can_ be implemented via a DFA, and perhaps in some
cases, quite quickly via a [shift DFA]. Beyond that though, multiple substring
search can be implemented by other various algorithms such as Aho-Corasick or
Rabin-Karp. (The standard Aho-Corasick formulation is an NFA, but it can also
be converted to a DFA by pre-computing all failure transitions. This winds up
with a similar result as using Thompson's construction to produce an NFA and
then powerset construction to get a DFA, but the Aho-Corasick construction
algorithm is usually quite a bit faster because it doesn't need to deal with a
full NFA.)

The problem here is that DFA speeds may or may not help you. For example, in
the case of RE2 and Rust's regex engine, it will already get DFA speeds by
virtue of their lazy DFAs. Indeed, in this group, RE2 performs roughly the same
across all benchmarks. So even if you, say build an Aho-Corasick DFA, it's not
going to help much if at all. So it makes sense to avoid it.

But Rust's regex crate has quite a bit higher throughputs than RE2 on most of
the benchmarks in this group. So how is it done? Currently, this is done via
the [Teddy] algorithm, which was ported out of [Hyperscan]. It is an algorithm
that makes use of SIMD to accelerate searching for a somewhat small set of
literals. Most regex engines don't have this sort of optimization, and indeed,
it seems like Teddy is not particularly well known. Alas, regex engines that
want to move past typical DFA speeds for multiple substring search likely need
some kind of vectorized algorithm to do so. (Teddy is also used by Rust's
regex crate in the previous `literal` group of benchmarks for accelerating
case insensitive searches. Namely, it enumerates some finite set of prefixes
like `she`, `SHE`, `ShE` and so on, and then looks for matches of those as a
prefilter.)

[shift DFA]: https://gist.github.com/pervognsen/218ea17743e1442e59bb60d29b1aa725
[Teddy]: https://github.com/BurntSushi/aho-corasick/tree/4e7fa3b85dd3a3ce882896f1d4ee22b1f271f0b4/src/packed/teddy
[Hyperscan]: https://github.com/intel/hyperscan

| Engine | sherlock-en | sherlock-casei-en | sherlock-ru | sherlock-casei-ru | sherlock-zh |
| - | - | - | - | - | - |
| dotnet/compiled | 3.7 GB/s | 446.7 MB/s | 2.2 GB/s | 784.2 MB/s | 16.2 GB/s |
| dotnet/nobacktrack | 2.6 GB/s | 374.5 MB/s | 1012.0 MB/s | 293.7 MB/s | 10.5 GB/s |
| go/regexp | 24.8 MB/s | 15.3 MB/s | 31.8 MB/s | 9.0 MB/s | 45.7 MB/s |
| hyperscan | **17.2 GB/s** | **15.3 GB/s** | 4.6 GB/s | **4.0 GB/s** | **20.0 GB/s** |
| pcre2 | 884.1 MB/s | 157.9 MB/s | 1741.0 KB/s | 1630.0 KB/s | 8.5 MB/s |
| pcre2/jit | 1559.1 MB/s | 654.6 MB/s | 1198.2 MB/s | 297.2 MB/s | 2.3 GB/s |
| perl | 1089.9 MB/s | 113.9 MB/s | 129.7 MB/s | 74.3 MB/s | 225.5 MB/s |
| python/re | 439.8 MB/s | 36.4 MB/s | 411.5 MB/s | 55.7 MB/s | 1031.1 MB/s |
| python/regex | 302.0 MB/s | 71.6 MB/s | 302.6 MB/s | 78.6 MB/s | 874.3 MB/s |
| re2 | 923.5 MB/s | 922.7 MB/s | 918.9 MB/s | 930.3 MB/s | 964.8 MB/s |
| regress | 1640.2 MB/s | 310.7 MB/s | 275.8 MB/s | 115.9 MB/s | 283.1 MB/s |
| rust/regex | 15.2 GB/s | 2.7 GB/s | 2.9 GB/s | 516.5 MB/s | 18.4 GB/s |
| rust/regex/meta | 12.7 GB/s | 2.9 GB/s | **6.3 GB/s** | 1646.6 MB/s | 14.9 GB/s |
| rust/regexold | 16.7 GB/s | 2.9 GB/s | 3.0 GB/s | 453.9 MB/s | 16.4 GB/s |

<details>
<summary>Show individual benchmark parameters.</summary>

**sherlock-en**

| Parameter | Value |
| --------- | ----- |
| full name | `curated/02-literal-alternate/sherlock-en` |
| model | [`count`](MODELS.md#count) |
| regex | `````Sherlock Holmes\|John Watson\|Irene Adler\|Inspector Lestrade\|Professor Moriarty````` |
| case-insensitive | `false` |
| unicode | `false` |
| haystack-path | [`opensubtitles/en-sampled.txt`](benchmarks/haystacks/opensubtitles/en-sampled.txt) |
| count | 714 |


**sherlock-casei-en**

| Parameter | Value |
| --------- | ----- |
| full name | `curated/02-literal-alternate/sherlock-casei-en` |
| model | [`count`](MODELS.md#count) |
| regex | `````Sherlock Holmes\|John Watson\|Irene Adler\|Inspector Lestrade\|Professor Moriarty````` |
| case-insensitive | `true` |
| unicode | `false` |
| haystack-path | [`opensubtitles/en-sampled.txt`](benchmarks/haystacks/opensubtitles/en-sampled.txt) |
| count | 725 |


**sherlock-ru**

| Parameter | Value |
| --------- | ----- |
| full name | `curated/02-literal-alternate/sherlock-ru` |
| model | [`count`](MODELS.md#count) |
| regex | `````Шерлок Холмс\|Джон Уотсон\|Ирен Адлер\|инспектор Лестрейд\|профессор Мориарти````` |
| case-insensitive | `false` |
| unicode | `true` |
| haystack-path | [`opensubtitles/ru-sampled.txt`](benchmarks/haystacks/opensubtitles/ru-sampled.txt) |
| count | 899 |


**sherlock-casei-ru**

| Parameter | Value |
| --------- | ----- |
| full name | `curated/02-literal-alternate/sherlock-casei-ru` |
| model | [`count`](MODELS.md#count) |
| regex | `````Шерлок Холмс\|Джон Уотсон\|Ирен Адлер\|инспектор Лестрейд\|профессор Мориарти````` |
| case-insensitive | `true` |
| unicode | `true` |
| haystack-path | [`opensubtitles/ru-sampled.txt`](benchmarks/haystacks/opensubtitles/ru-sampled.txt) |
| count | 971 |


**sherlock-zh**

| Parameter | Value |
| --------- | ----- |
| full name | `curated/02-literal-alternate/sherlock-zh` |
| model | [`count`](MODELS.md#count) |
| regex | `````夏洛克·福尔摩斯\|约翰华生\|阿德勒\|雷斯垂德\|莫里亚蒂教授````` |
| case-insensitive | `false` |
| unicode | `true` |
| haystack-path | [`opensubtitles/zh-sampled.txt`](benchmarks/haystacks/opensubtitles/zh-sampled.txt) |
| count | 207 |


</details>

#### date

This is a monster regex for extracting dates from unstructured text from
the [datefinder] project written in Python. The regex itself was taken from
[printing the `DATES_PATTERN`][datefinder-regex] variable in the `datefinder`
project. I then removed all names from the capture groups, unnecessary escapes
and collapsed it to a single line (because not all regex engines support
verbose mode).

The regex is more akin to a tokenizer, and the `datefinder` library attempts to
combine these tokens into timestamps.

We measure an ASCII only version of it and a Unicode-aware version of it.
Unicode is relevant here because of case insensitivity, and because the regex
makes use of the character classes `\s` and `\d`, which are bigger when they're
Unicode aware. We also measure the compilation time of each.

The results here can be a little tricky to interpret. Namely, it looks like
backtrackers tend to do worse than automata oriented regex engines, but
`go/regexp` uses automata and is itself quite slow here. Notice, though, that
`hyperscan`, `re2` and `rust/regex` do well here. While I'm less familiar with
`hyperscan`, the explanation for `re2` and `rust/regex` is obvious once you
look at a profile: it's the lazy DFA. Both have implementations of a regex
engine that build a DFA during search time, with at most one new transition
(and one new state) being create per byte of haystack. In practice, most
transitions get reused, which means that it tends to act like a real DFA most
of the time for most regexes on most haystacks.

Compilation time of this monster regex is also all over the place. PCRE2 does
the best, and Hyperscan winds up being quite slow. Once you enable Unicode
mode, compilation time generally gets worse, and especially so for `re2` and
`rust/regex`. In particular, both compile _byte oriented_ automata, which means
the transitions are defined over bytes and not codepoints. That means large
Unicode classes like `\d` tend to balloon in size, because they get converted
into UTF-8 automata.

[datefinder]: https://github.com/akoumjian/datefinder/tree/master
[datefinder-regex]: https://github.com/akoumjian/datefinder/blob/5376ece0a522c44762b1ab656fc80737b427ed16/datefinder/constants.py#L112-L124

| Engine | ascii | unicode | compile-ascii | compile-unicode |
| - | - | - | - | - |
| dotnet/compiled | - | 1156.5 KB/s | - | 1.67ms |
| go/regexp | 252.4 KB/s | - | 4.06ms | - |
| hyperscan | 105.1 MB/s | - | 651.02ms | - |
| pcre2 | 1218.8 KB/s | 173.8 KB/s | **114.49us** | **131.45us** |
| pcre2/jit | 21.2 MB/s | 13.0 MB/s | 714.35us | 0.98ms |
| perl | 2.8 MB/s | - | - | - |
| python/re | 1082.2 KB/s | 796.4 KB/s | 4.82ms | 4.99ms |
| python/regex | 1111.0 KB/s | 1004.0 KB/s | 15.38ms | 36.18ms |
| re2 | 75.4 MB/s | - | 1.16ms | - |
| regress | - | 2.0 MB/s | 1.05ms | - |
| rust/regex | 134.2 MB/s | **133.5 MB/s** | 1.95ms | 6.19ms |
| rust/regex/meta | 123.2 MB/s | 120.9 MB/s | 1.49ms | 5.33ms |
| rust/regexold | **137.8 MB/s** | 413.7 KB/s | 1.69ms | 6.19ms |

<details>
<summary>Show individual benchmark parameters.</summary>

**ascii**

| Parameter | Value |
| --------- | ----- |
| full name | `curated/03-date/ascii` |
| model | [`count-spans`](MODELS.md#count-spans) |
| regex-path | [`wild/date.txt`](benchmarks/regexes/wild/date.txt) |
| case-insensitive | `true` |
| unicode | `false` |
| haystack-path | [`rust-src-tools-3b0d4813.txt`](benchmarks/haystacks/rust-src-tools-3b0d4813.txt) |
| count(\*) | 111817 |
| count(hyperscan) | 547662 |

As with many other benchmarks, Hyperscan reports all matches, even ones that
are overlapping. This particular regex is too big to analyze closely, but it
seems plausible one could still use it (possibly with a slightly tweaked regex)
for this task.

**unicode**

| Parameter | Value |
| --------- | ----- |
| full name | `curated/03-date/unicode` |
| model | [`count-spans`](MODELS.md#count-spans) |
| regex-path | [`wild/date.txt`](benchmarks/regexes/wild/date.txt) |
| case-insensitive | `true` |
| unicode | `true` |
| haystack-path | [`rust-src-tools-3b0d4813.txt`](benchmarks/haystacks/rust-src-tools-3b0d4813.txt) |
| count(\*) | 111841 |
| count(dotnet/compiled) | 111825 |

`regress` is included here despite its `\d` not being Unicode-aware (as
required by ECMAScript). Notably, its `\s` _is_ Unicode aware. (`\w` is too,
but it's not used in this regex.) In this particular haystack, `\d` being
ASCII-only doesn't impact the match count.

However, neither `re2` nor `go/regexp` are included here because neither `\d`
nor `\s` are Unicode-aware, and the `\s` being ASCII-only does impact the match
count.

`hyperscan` is excluded here because the pattern results in a "too large"
compilation error. As far as I know, Hyperscan doesn't expose any knobs for
increasing this limit.

`dotnet/compiled` gets a different count here, but it's not clear why.

`perl` is left out of this benchmark because it times out.

**compile-ascii**

| Parameter | Value |
| --------- | ----- |
| full name | `curated/03-date/compile-ascii` |
| model | [`compile`](MODELS.md#compile) |
| regex-path | [`wild/date.txt`](benchmarks/regexes/wild/date.txt) |
| case-insensitive | `true` |
| unicode | `false` |
| haystack | `2010-03-14` |
| count(\*) | 5 |
| count(hyperscan) | 10 |

Notice that `regress` is now include in the ASCII benchmark, because in
`compile-unicode` we specifically test that the `\d` used in this regex is
Unicode-aware. `regress` does not make `\d` Unicode-aware, so it gets thrown
into the ASCII group. But do note that it does appear to have some Unicode
awareness.

**compile-unicode**

| Parameter | Value |
| --------- | ----- |
| full name | `curated/03-date/compile-unicode` |
| model | [`compile`](MODELS.md#compile) |
| regex-path | [`wild/date.txt`](benchmarks/regexes/wild/date.txt) |
| case-insensitive | `true` |
| unicode | `true` |
| haystack | `۲۰۱۰-۰۳-۱۴` |
| count | 5 |

We use "extended arabic-indic digits" to represent the same date, `2010-03-14`,
that we use for verification in `compile-ascii`. These digits are part of `\d`
when it is Unicode aware.

</details>

#### ruff-noqa

The regex benchmarked here comes from the [Ruff project][ruff], which is a
Python linter written in Rust. The project uses many regexes, but [we pluck
one out in particular][noqa] that is likely to be run more frequently than the
others:

```
(\s*)((?i:# noqa)(?::\s?(([A-Z]+[0-9]+(?:[,\s]+)?)+))?)
```

This is a regex that looks for `# noqa` annotations on each line. The `noqa`
annotation generally causes the linter to ignore those lines with respect to
warnings it emits. The regex also tries to extract annotations following the
`noqa` that permit ignoring only specific rules in the linter.

This benchmark has a few interesting characteristics worth pointing out:

* It is line oriented, which means the haystacks it searches are likely to be
small. This in turn means that the overhead of the regex engine is likely to
matter more than in throughput oriented benchmarks.
* On this particular haystack (the CPython source code), the number of matches
is quite small. Therefore, it is quite beneficial here to be able to have a
fast path to say "there is no match" without doing any extra work. While the
number of matches here is perhaps uncharacteristically small for a Python
project, you would generally expect _most_ lines to not have `# noqa` in them,
and so the presumption of a fast rejection is probably a decent assumption for
this particular regex.
* Ruff uses capturing groups to pick out parts of the match, so when a match
is found, the regex engine needs to report additional information beyond just
the overall match spans. The spans of each matching capture group also need
to be reported.
* There are no prefix (or suffix) literals in the regex to enable any
straight-forward prefilter optimizations.

With respect to the point about no prefix or suffix literals, we also include
a tweaked version of the regex that removes the leading `(\s*)`:

```
(?i:# noqa)(?::\s?(([A-Z]+[0-9]+(?:[,\s]+)?)+))?
```

In this case, the regex now starts with a literal, albeit one that is asked
to match case insensitively. We can actually see pretty clearly the impact
the tweaked version has on the speed for each regex engine. `pcre2/jit`, for
example, improves its throughput from around 500 MB/s to 1.5 GB/s. `go/regexp`
has an even more dramatic (relatively speaking) improvement.

`rust/regex` is a little different in that it's quite fast in both cases.
The key optimization that applies for `rust/regex` is the "reverse inner"
optimization. Even in the original regex, `rust/regex` will pluck out the `#
noqa` literal and search for it case insensitively. When a candidate is found,
it then searches for `(\s*)` in reverse to find the start position, and then
finally does a standard forward search from that point to find the reverse
position.

[ruff]: https://github.com/charliermarsh/ruff
[noqa]: https://github.com/charliermarsh/ruff/blob/5c987874c48e6ed5d0ef7f9a09c4cb1940bd4018/crates/ruff/src/noqa.rs#L22

| Engine | real | tweaked |
| - | - | - |
| dotnet/compiled | 154.3 MB/s | 506.0 MB/s |
| dotnet/nobacktrack | 242.1 MB/s | 444.9 MB/s |
| go/regexp | 32.7 MB/s | 712.3 MB/s |
| pcre2 | 122.2 MB/s | 1415.9 MB/s |
| pcre2/jit | 571.1 MB/s | 1507.5 MB/s |
| perl | 103.3 MB/s | 133.4 MB/s |
| python/re | 28.7 MB/s | 108.6 MB/s |
| python/regex | 97.4 MB/s | 97.0 MB/s |
| re2 | 535.6 MB/s | 710.9 MB/s |
| rust/regex | 735.1 MB/s | 1318.4 MB/s |
| rust/regex/meta | **1665.3 MB/s** | **1523.8 MB/s** |
| rust/regexold | 196.2 MB/s | 1225.6 MB/s |

<details>
<summary>Show individual benchmark parameters.</summary>

**real**

| Parameter | Value |
| --------- | ----- |
| full name | `curated/04-ruff-noqa/real` |
| model | [`grep-captures`](MODELS.md#grep-captures) |
| regex | `````(\s*)((?i:# noqa)(?::\s?(([A-Z]+[0-9]+(?:[,\s]+)?)+))?)````` |
| case-insensitive | `false` |
| unicode | `false` |
| haystack-path | [`wild/cpython-226484e4.py`](benchmarks/haystacks/wild/cpython-226484e4.py) |
| count | 84 |


**tweaked**

| Parameter | Value |
| --------- | ----- |
| full name | `curated/04-ruff-noqa/tweaked` |
| model | [`grep-captures`](MODELS.md#grep-captures) |
| regex | `````(?i:# noqa)(?::\s?(([A-Z]+[0-9]+(?:[,\s]+)?)+))?````` |
| case-insensitive | `false` |
| unicode | `false` |
| haystack-path | [`wild/cpython-226484e4.py`](benchmarks/haystacks/wild/cpython-226484e4.py) |
| count | 44 |


</details>

#### lexer-veryl

This group benchmarks a "lexer" where it combines a whole bunch of different
patterns that identify tokens in a language into a single regex. It then uses
capture groups to determine which branch of the alternation actually matched,
and thus, which token matched. We also benchmark a variant of this that asks
the regex engine to search for each pattern individually (most regex engines
don't support this mode).

This is used by the [Veryl] project by way of the [Parol] parser generator. The
regex was [extracted by the Parol maintainers upon my request][parol-issue].

We use this regex to represent the "lexing" use case, where sometimes folks
will build a pretty big regex with a bunch of small regexes for identifying
tokens. Usually the idea is that the lexer matches literally everything in the
haystack (indeed, the last branch in this regex is a `.` and the first is any
newline), and thus these sorts of regexes tend to be quite latency sensitive.
Namely, it really matters just how much overhead is involved in reporting
matches. This is likely one of the reasons why most regex engines are overall
pretty slow here.

The other aspect of this that's quite difficult is the sheer number of
capturing groups. There's several dozen of them, which means regex engines have
to keep track of a fair bit of state to handle it.

You might think this would be bad for backtrackers and good for automata
engines, since automata engines are *supposed* to be able to handle large
alternations better than backtrackers. But that's not the case here. Even for
example Python's regex engine (backtracker) beats RE2 (automata). My hypothesis
for why this is, is latency. Automata engines tend to have multiple engines
internally and therefore tend to have higher latency, and sometimes multiple
engines run to service one search. Backtrackers tend to have one engine that
handles everything. But still, shouldn't the huge alternation be disastrous for
the backtracker? Perhaps, unless many of the matches occur in an early branch,
which is likely the case here. Namely, the second alternation matches a ` `
(single ASCII space), which is probably the most frequently occurring byte in
the haystack. An automata engine that doesn't use a DFA (which might be the
case here, because the regex is so big), will wind up spending a lot of time
keeping track of all branches of the alternation, even if it doesn't need to
explore all of them. In contrast, a backtracker will try one after the other,
and if most cases match an early branch, the backtracker is likely to take less
overall time.

Most regex engines are stuck in the 1 MB/s (or less) range. The regex crate and
PCRE2's JIT get up to about 10 MB/s, with PCRE2 edging out the regex crate.

Note that the regex was lightly modified from the original to increase
portability across different regex engines. For example, the `[\s--\r\n]` class
was changed to `[\t\v\f ]`.

As for the second benchmark, `multiple`, it uses the same patterns from each
alternation in the `single` benchmark, but treats each one as a distinct
pattern. Doing this requires explicit support for searching multiple regex
patterns. (RE2's and Rust's regex crate "regex set" functionality is not enough
for this, as it only reports which patterns match a haystack, and not where
they match. That's why the lower level `regex/automata/meta` engine is used,
which exposes a more powerful but more complex API.)

In the `multiple` case, the `rust/regex/meta` does very well and the key reason
is the abdication of capture groups as a necessary tool to determine which
token matched. Namely, now we can simply use a pattern ID from the match to
determine which "branch" in the original regex was taken. We no longer need to
ask for or inspect capture groups. This gives a critical benefit to automata
engines that support searching for multiple patterns, because it no longer
requires them to use slower engines for resolving capturing groups.

[Veryl]: https://github.com/dalance/veryl
[Parol]: https://github.com/jsinger67/parol
[parol-issue]: https://github.com/jsinger67/parol/issues/56

| Engine | single | compile-single | multi |
| - | - | - | - |
| dotnet/compiled | 195.3 KB/s | 270.13us | - |
| go/regexp | 317.1 KB/s | 186.96us | - |
| hyperscan | - | - | 17.8 MB/s |
| pcre2 | 3.0 MB/s | **19.84us** | - |
| pcre2/jit | **13.0 MB/s** | 121.71us | - |
| perl | 1171.1 KB/s | - | - |
| python/re | 1572.1 KB/s | 936.11us | - |
| python/regex | 1426.9 KB/s | 2.92ms | - |
| re2 | 1217.7 KB/s | 141.79us | - |
| rust/regex | 235.9 KB/s | 280.24us | - |
| rust/regex/meta | 9.5 MB/s | 257.56us | **62.4 MB/s** |
| rust/regexold | 238.8 KB/s | 249.67us | - |

<details>
<summary>Show individual benchmark parameters.</summary>

**single**

| Parameter | Value |
| --------- | ----- |
| full name | `curated/05-lexer-veryl/single` |
| model | [`count-captures`](MODELS.md#count-captures) |
| regex-path | [`wild/parol-veryl.txt`](benchmarks/regexes/wild/parol-veryl.txt) |
| case-insensitive | `false` |
| unicode | `false` |
| haystack-path | [`wild/parol-veryl.vl`](benchmarks/haystacks/wild/parol-veryl.vl) |
| count | 124800 |

Note that we don't include Hyperscan here because it doesn't support the
`count-captures` benchmark model. It is included in the `multiple` benchmark
below, which doesn't require capture groups.

Also, I tried to use `dotnet/nobacktrack` here, but it failed because it was
too big and it wasn't obvious to me how to raise the limit.

**compile-single**

| Parameter | Value |
| --------- | ----- |
| full name | `curated/05-lexer-veryl/compile-single` |
| model | [`compile`](MODELS.md#compile) |
| regex-path | [`wild/parol-veryl.txt`](benchmarks/regexes/wild/parol-veryl.txt) |
| case-insensitive | `false` |
| unicode | `false` |
| haystack | `abcdefg_foobar` |
| count | 1 |

This measures how long it takes to a compile a moderately large lexer.

**multi**

| Parameter | Value |
| --------- | ----- |
| full name | `curated/05-lexer-veryl/multi` |
| model | [`count-spans`](MODELS.md#count-spans) |
| regex-path | [`wild/parol-veryl.txt`](benchmarks/regexes/wild/parol-veryl.txt) |
| case-insensitive | `false` |
| unicode | `false` |
| haystack-path | [`wild/parol-veryl.vl`](benchmarks/haystacks/wild/parol-veryl.vl) |
| count(\*) | 150600 |
| count(hyperscan) | 669500 |

Hyperscan reports everything that matches, including overlapping matches,
and that's why its count is higher. It is likely still serviceable for
this use case, but might in practice require changing the regex to suit
Hyperscan's match semantics. Still, it's a decent barometer to include it here,
particularly because of its multi-regex support.

Most regex engines do not support searching for multiple patterns and finding
the corresponding match offsets, which is why this benchmark has very few
entries.

</details>

#### cloud-flare-redos

This benchmark uses a regex that helped cause an [outage at
Cloudflare][cloudflare-blog]. This class of vulnerability is typically called a
"regular expression denial of service," or "ReDoS" for short. It doesn't always
require a malicious actor to trigger. Since it can be difficult to reason about
the worst case performance of a regex when using an unbounded backtracking
implementation, it might happen entirely accidentally on valid inputs.

The particular regex that contributed to the outage was:

```
(?:(?:"|'|\]|\}|\\|\d|(?:nan|infinity|true|false|null|undefined|symbol|math)|`|\-|\+)+[)]*;?((?:\s|-|~|!|\{\}|\|\||\+)*.*(?:.*=.*)))
```

As discussed in Cloudflare's post mortem, the specific problematic portion of
the regex is:

```
.*(?:.*=.*)
```

Or more simply:

```
.*.*=.*;
```

We benchmark the original regex along with the simplified variant. We also
split the simplified variant into one with a short haystack (about 100 bytes)
and one with a long haystack (about 10,000 bytes). The benchmark results for
the original and simplified short variant should be roughly similar, but the
difference between the short and long variant is where things get interesting.
The automata based engines generally maintain a similar throughput for both the
short and long benchmarks, but the backtrackers slow way down. This is because
the backtracking algorithm for this specific regex and haystack doesn't scale
linearly with increases in the size of the haystack.

The purpose of this benchmark is to show a real world scenario where the use of
a backtracking engine can bite you in production if you aren't careful.

We include Hyperscan in this benchmark, although it is questionable to do so.
Hyperscan reports many overlapping matches from the regex used by Cloudflare
because of the trailing `.*`, so it is probably not a great comparison.
In particular, this regex was originally used in a firewall, so it seems
likely that it would be used in a "is a match" or "not a match" scenario. But
our benchmark here reproduces the analysis in the appendix of Cloudflare's
port mortem. But the real utility in including Hyperscan here is that it
demonstrates that it is not a backtracking engine. While its throughput is not
as high as some other engines, it remains roughly invariant with respect to
haystack length, just like other automata oriented engines.

Note that `rust/regex` has very high throughput here because the regex is
small enough to get compiled into a full DFA. The compilation process also
"accelerates" some states, particularly the final `.*`. This acceleration works
by noticing that almost all of the state's transitions loop back on itself, and
only a small number transition to another state. The final `.*` for example
only leaves its state if it sees the end of the haystack or a `\n`. So the DFA
will actually run `memchr` on `\n` and skip right to the end of the haystack.

[cloudflare-blog]: https://blog.cloudflare.com/details-of-the-cloudflare-outage-on-july-2-2019/

| Engine | original | simplified-short | simplified-long |
| - | - | - | - |
| dotnet/compiled | 131.0 MB/s | 845.9 MB/s | 13.5 GB/s |
| dotnet/nobacktrack | 12.9 MB/s | 188.5 MB/s | 288.9 MB/s |
| go/regexp | 41.0 MB/s | 44.6 MB/s | 47.1 MB/s |
| hyperscan | 85.8 MB/s | 81.7 MB/s | 84.9 MB/s |
| pcre2 | 2.9 MB/s | 2.8 MB/s | 30.2 KB/s |
| pcre2/jit | 49.8 MB/s | 41.6 MB/s | 671.2 KB/s |
| perl | 10.4 MB/s | 10.1 MB/s | 176.6 KB/s |
| python/re | 22.2 MB/s | 22.0 MB/s | 337.9 KB/s |
| python/regex | 6.2 MB/s | 6.0 MB/s | 91.8 KB/s |
| re2 | 347.1 MB/s | 333.1 MB/s | 493.7 MB/s |
| regress | 9.2 MB/s | 8.9 MB/s | 115.3 KB/s |
| rust/regex | 457.6 MB/s | 498.8 MB/s | 588.7 MB/s |
| rust/regex/meta | **570.1 MB/s** | **1768.6 MB/s** | **82.4 GB/s** |
| rust/regexold | 468.1 MB/s | 491.3 MB/s | 599.5 MB/s |

<details>
<summary>Show individual benchmark parameters.</summary>

**original**

| Parameter | Value |
| --------- | ----- |
| full name | `curated/06-cloud-flare-redos/original` |
| model | [`count-spans`](MODELS.md#count-spans) |
| regex | `````(?:(?:"\|'\|\]\|\}\|\\\|\d\|(?:nan\|infinity\|true\|false\|null\|undefined\|symbol\|math)\|`\|-\|\+)+[)]*;?((?:\s\|-\|~\|!\|\{\}\|\\|\\|\|\+)*.*(?:.*=.*)))````` |
| case-insensitive | `false` |
| unicode | `false` |
| haystack | `math x=xxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxx [.. snip ..]` |
| count(\*) | 107 |
| count(hyperscan) | 5757 |


**simplified-short**

| Parameter | Value |
| --------- | ----- |
| full name | `curated/06-cloud-flare-redos/simplified-short` |
| model | [`count-spans`](MODELS.md#count-spans) |
| regex | `````.*.*=.*````` |
| case-insensitive | `false` |
| unicode | `false` |
| haystack | `x=xxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxx [.. snip ..]` |
| count(\*) | 102 |
| count(hyperscan) | 5252 |


**simplified-long**

| Parameter | Value |
| --------- | ----- |
| full name | `curated/06-cloud-flare-redos/simplified-long` |
| model | [`count-spans`](MODELS.md#count-spans) |
| regex | `````.*.*=.*````` |
| case-insensitive | `false` |
| unicode | `false` |
| haystack-path | [`cloud-flare-redos.txt`](benchmarks/haystacks/cloud-flare-redos.txt) |
| count(\*) | 10000 |
| count(hyperscan) | 50004999 |


</details>

#### unicode-character-data

This regex parses data from `UnicodeData.txt`, which is part of the [Unicode
Character Database][ucd]. This regex was [extracted from the `ucd-parse`
crate][ucd-parse-regex], which is part of the [ucd-generate] project.

This benchmark works by iterating over every line in the haystack and then
running the regex on each line. Every line matches the regex, so regex engines
that attempt to do some extra work to reject non-matches quickly will get
penalized. For example, `rust/regex` looks for a semi-colon first via its
"reverse inner" optimization, since a semi-colon is a required part of the
regex. But this optimization is just extra work here. Indeed, disabling it will
improve the thoughput of `rust/regex` on this benchmark.

`pcre2/jit` does remarkably well here, and these types of regexes are one of
the many things that `pcre2/jit` does quickly compared to most other regex
engines.

We also include compilation time for this regex, where PCRE2 again does quite
well.

[ucd]: https://unicode.org/ucd/
[ucd-generate]: https://github.com/BurntSushi/ucd-generate
[ucd-parse-regex]: https://github.com/BurntSushi/ucd-generate/blob/47ae5cbe739d46d3d2eed75e1326d9814d940c3f/ucd-parse/src/unicode_data.rs#L103-L124

| Engine | parse-line | compile |
| - | - | - |
| dotnet/compiled | 86.0 MB/s | 41.61us |
| dotnet/nobacktrack | 17.1 MB/s | 152.18us |
| go/regexp | 65.4 MB/s | 39.51us |
| pcre2 | 200.1 MB/s | **2.11us** |
| pcre2/jit | **707.4 MB/s** | 12.50us |
| perl | 23.4 MB/s | - |
| python/re | 44.7 MB/s | 128.16us |
| python/regex | 35.3 MB/s | 406.11us |
| re2 | 108.4 MB/s | 14.89us |
| regress | 213.0 MB/s | 5.87us |
| rust/regex | 94.2 MB/s | 22.54us |
| rust/regex/meta | 225.6 MB/s | 28.18us |
| rust/regexold | 94.7 MB/s | 18.95us |

<details>
<summary>Show individual benchmark parameters.</summary>

**parse-line**

| Parameter | Value |
| --------- | ----- |
| full name | `curated/07-unicode-character-data/parse-line` |
| model | [`grep-captures`](MODELS.md#grep-captures) |
| regex-path | [`wild/ucd-parse.txt`](benchmarks/regexes/wild/ucd-parse.txt) |
| case-insensitive | `false` |
| unicode | `false` |
| haystack-path | [`wild/UnicodeData-15.0.0.txt`](benchmarks/haystacks/wild/UnicodeData-15.0.0.txt) |
| count | 558784 |


**compile**

| Parameter | Value |
| --------- | ----- |
| full name | `curated/07-unicode-character-data/compile` |
| model | [`compile`](MODELS.md#compile) |
| regex-path | [`wild/ucd-parse.txt`](benchmarks/regexes/wild/ucd-parse.txt) |
| case-insensitive | `false` |
| unicode | `false` |
| haystack | `249D;PARENTHESIZED LATIN SMALL LETTER B;So;0;L;<compat> 0028 [.. snip ..]` |
| count | 1 |


</details>

#### words

This benchmark measures how long it takes for a regex engine to find words in
a haystack. We compare one regex that finds all words, `\b\w+\b` and another
regex that only looks for longer words, `\b\w{12,}\b`. We also compare ASCII
regexes on English text with Unicode regexes on Russian text.

The split between finding all words and finding only long words tends to
highlight the overhead of matching in each regex engine. Regex engines that are
quicker to get in and out of its match routine do better at finding all words
than regex engines that have higher overhead. For example, `regress` is faster
than `rust/regex` on `all-english`, but substantially slower than `rust/regex`
on `long-english`. This is likely because `rust/regex` is doing more work per
search call than `regress`, which is in part rooted in the optimizations it
performs to gain higher throughput.

Otherwise, `pcre2/jit` does quite well here across the board, but especially on
the Unicode variants. When comparing it against `rust/regex` for example, it
is substantially faster. In the case of `rust/regex`, its faster DFA oriented
engines cannot handle the Unicode aware `\b` on non-ASCII haystacks, and this
causes `rust/regex` to use a slower internal engine. It's so slow in fact
that `python/re` and `python/regex` are both faster than `rust/regex` for the
Unicode benchmarks. For the ASCII `long-english` benchmark, `rust/regex` and
`re2` both do well because most of the time is spent in its lazy DFA, which has
pretty good throughput performance when compared to a pure backtracker.

Note that several regex engines can't be used in the Unicode variants because
either they don't support a Unicode aware `\w` or because they don't support a
Unicode aware `\b` (or both).

| Engine | all-english | all-russian | long-english | long-russian |
| - | - | - | - | - |
| dotnet/compiled | 59.2 MB/s | 94.6 MB/s | 178.6 MB/s | 114.8 MB/s |
| dotnet/nobacktrack | 29.5 MB/s | 38.4 MB/s | 142.8 MB/s | 124.4 MB/s |
| go/regexp | 11.2 MB/s | - | 44.7 MB/s | - |
| hyperscan | 158.0 MB/s | - | 445.0 MB/s | - |
| pcre2 | 95.6 MB/s | 130.3 KB/s | 70.7 MB/s | 6.2 MB/s |
| pcre2/jit | **190.1 MB/s** | **228.2 MB/s** | 245.2 MB/s | **195.7 MB/s** |
| perl | 13.6 MB/s | 35.1 KB/s | 104.9 MB/s | 1869.3 KB/s |
| python/re | 33.6 MB/s | 43.9 MB/s | 110.1 MB/s | 113.7 MB/s |
| python/regex | 24.6 MB/s | 45.1 MB/s | 36.4 MB/s | 101.9 MB/s |
| re2 | 62.8 MB/s | - | **920.8 MB/s** | - |
| regress | 167.9 MB/s | - | 153.1 MB/s | - |
| rust/regex/meta | 110.9 MB/s | 17.1 MB/s | 800.9 MB/s | 30.2 MB/s |

<details>
<summary>Show individual benchmark parameters.</summary>

**all-english**

| Parameter | Value |
| --------- | ----- |
| full name | `curated/08-words/all-english` |
| model | [`count-spans`](MODELS.md#count-spans) |
| regex | `````\b[0-9A-Za-z_]+\b````` |
| case-insensitive | `false` |
| unicode | `false` |
| haystack-path | [`opensubtitles/en-sampled.txt`](benchmarks/haystacks/opensubtitles/en-sampled.txt) |
| count(\*) | 56691 |
| count(dotnet/compiled) | 56601 |
| count(dotnet/nobacktrack) | 56601 |

We specifically write out `[0-9A-Za-z_]` instead of using `\w` because some
regex engines, such as the one found in .NET, make `\w` Unicode aware and there
doesn't appear to be any easy way of disabling it.

Also, the .NET engine makes `\b` Unicode-aware, which also appears impossible
to disable. To account for that, we permit a different count.

**all-russian**

| Parameter | Value |
| --------- | ----- |
| full name | `curated/08-words/all-russian` |
| model | [`count-spans`](MODELS.md#count-spans) |
| regex | `````\b\w+\b````` |
| case-insensitive | `false` |
| unicode | `true` |
| haystack-path | [`opensubtitles/ru-sampled.txt`](benchmarks/haystacks/opensubtitles/ru-sampled.txt) |
| count(\*) | 107391 |
| count(dotnet/compiled) | 53960 |
| count(dotnet/nobacktrack) | 53960 |
| count(perl) | 53960 |

`regress`, `re2` and `go/regexp` are excluded because `\w` is not Unicode
aware. `hyperscan` is exclude because it doesn't support a Unicode aware `\b`.

For `dotnet/compiled`, since the length of matching spans is in the number of
UTF-16 code units, its expected count is smaller.

For `perl`, it has the same count as `dotnet/compiled`, but only because it
counts total encoded codepoints. Since every match span in this benchmark
seemingly corresponds to codepoints in the basic multi-lingual plane, it
follows that the number of UTF-16 code units is equivalent to the number of
codepoints.

**long-english**

| Parameter | Value |
| --------- | ----- |
| full name | `curated/08-words/long-english` |
| model | [`count-spans`](MODELS.md#count-spans) |
| regex | `````\b[0-9A-Za-z_]{12,}\b````` |
| case-insensitive | `false` |
| unicode | `false` |
| haystack-path | [`opensubtitles/en-sampled.txt`](benchmarks/haystacks/opensubtitles/en-sampled.txt) |
| count | 839 |

We specifically write out `[0-9A-Za-z_]` instead of using `\w` because some
regex engines, such as the one found in .NET, make `\w` Unicode aware and there
doesn't appear to be any easy way of disabling it.

Also, the fact that `\b` is Unicode-aware in .NET does not seem to impact the
match counts in this benchmark.

**long-russian**

| Parameter | Value |
| --------- | ----- |
| full name | `curated/08-words/long-russian` |
| model | [`count-spans`](MODELS.md#count-spans) |
| regex | `````\b\w{12,}\b````` |
| case-insensitive | `false` |
| unicode | `true` |
| haystack-path | [`opensubtitles/ru-sampled.txt`](benchmarks/haystacks/opensubtitles/ru-sampled.txt) |
| count(\*) | 5481 |
| count(dotnet/compiled) | 2747 |
| count(dotnet/nobacktrack) | 2747 |
| count(perl) | 2747 |

`regress`, `re2` and `go/regexp` are excluded because `\w` is not Unicode
aware. `hyperscan` is exclude because it doesn't support a Unicode aware `\b`.

For `dotnet/compiled`, since the length of matching spans is in the number of
UTF-16 code units, its expected count is smaller.

For `perl`, it has the same count as `dotnet/compiled`, but only because it
counts total encoded codepoints. Since every match span in this benchmark
seemingly corresponds to codepoints in the basic multi-lingual plane, it
follows that the number of UTF-16 code units is equivalent to the number of
codepoints.

</details>

#### aws-keys

This [measures a regex][pypi-aws-secrets-regex] for [detecting AWS keys in
source code][pypi-aws-secrets-regex][aws-key-blog]. In particular, to reduce
false positives, it looks for both an access key and a secret key within a few
lines of one another.

We also measure a "quick" version of the regex that is used to find possible
candidates by searching for things that look like an AWS access key.

The measurements here demonstrate why the [pypi-aws-secrets] project splits
this task into two pieces. First it uses the "quick" version to identify
candidates, and then it uses the "full" version to lower the false positive
rate of the "quick" version. The "quick" version of the regex runs around
an order of magnitude faster than the "full" version across the board. To
understand why, let's look at the "quick" regex:

```
((?:ASIA|AKIA|AROA|AIDA)([A-Z0-7]{16}))
```

Given this regex, every match starts with one of `ASIA`, `AKIA`, `AROA` or
`AIDA`. This makes it quite amenable to prefilter optimizations where a regex
engine can look for matches of one of those 4 literals, and only then use the
regex engine to confirm whether there is a match at that position. Some regex
engines will also notice that every match starts with an `A` and use `memchr`
to look for occurrences of `A` as a fast prefilter.

We also include compilation times to give an idea of how long it takes
to compile a moderately complex regex, and how that might vary with the
compilation time of a much simpler version of the regex.

Note that in all of the measurements for this group, we search the CPython
source code (concatenated into one file). We also lossily convert it to UTF-8
so that regex engines like `regress` can participate in this benchmark. (The
CPython source code contains a very small amount of invalid UTF-8.)

[pypi-aws-secrets]: https://github.com/pypi-data/pypi-aws-secrets
[pypi-aws-secrets-regex]: https://github.com/pypi-data/pypi-aws-secrets/blob/903a7bd35bc8d9963dbbb7ca35e8ecb02e31bed4/src/scanners/mod.rs#L15-L23
[aws-key-blog]: https://tomforb.es/i-scanned-every-package-on-pypi-and-found-57-live-aws-keys/

| Engine | full | quick | compile-full | compile-quick |
| - | - | - | - | - |
| dotnet/compiled | 502.5 MB/s | 793.1 MB/s | 104.52us | 41.36us |
| dotnet/nobacktrack | - | 666.1 MB/s | - | 211.23us |
| go/regexp | 110.0 MB/s | 866.9 MB/s | 64.76us | 9.97us |
| hyperscan | - | 1341.2 MB/s | - | 6.97ms |
| pcre2 | 969.6 MB/s | 1498.0 MB/s | **3.61us** | **867.00ns** |
| pcre2/jit | 1241.8 MB/s | 1018.7 MB/s | 20.31us | 4.84us |
| perl | 104.9 MB/s | 138.8 MB/s | - | - |
| python/re | 94.9 MB/s | 165.0 MB/s | 208.10us | 48.18us |
| python/regex | 101.9 MB/s | 116.9 MB/s | 685.42us | 136.74us |
| re2 | 536.8 MB/s | 998.3 MB/s | 71.00us | 9.16us |
| regress | 278.9 MB/s | 708.9 MB/s | 8.56us | 2.09us |
| rust/regex | 664.3 MB/s | 1465.4 MB/s | 78.68us | 20.44us |
| rust/regex/meta | **1735.2 MB/s** | **1809.1 MB/s** | 84.42us | 14.67us |
| rust/regexold | 645.7 MB/s | 1440.9 MB/s | 71.60us | 18.64us |

<details>
<summary>Show individual benchmark parameters.</summary>

**full**

| Parameter | Value |
| --------- | ----- |
| full name | `curated/09-aws-keys/full` |
| model | [`grep-captures`](MODELS.md#grep-captures) |
| regex | `````(('\|")((?:ASIA\|AKIA\|AROA\|AIDA)([A-Z0-7]{16}))('\|").*?(\n^.*?){0,4}(('\|")[a-zA-Z0-9+/]{40}('\|"))+\|('\|")[a-zA-Z0-9+/]{40}('\|").*?(\n^.*?){0,3}('\|")((?:ASIA\|AKIA\|AROA\|AIDA)([A-Z0-7]{16}))('\|"))+````` |
| case-insensitive | `false` |
| unicode | `false` |
| haystack-path | [`wild/cpython-226484e4.py`](benchmarks/haystacks/wild/cpython-226484e4.py) |
| count | 0 |


**quick**

| Parameter | Value |
| --------- | ----- |
| full name | `curated/09-aws-keys/quick` |
| model | [`grep`](MODELS.md#grep) |
| regex | `````((?:ASIA\|AKIA\|AROA\|AIDA)([A-Z0-7]{16}))````` |
| case-insensitive | `false` |
| unicode | `false` |
| haystack-path | [`wild/cpython-226484e4.py`](benchmarks/haystacks/wild/cpython-226484e4.py) |
| count | 0 |


**compile-full**

| Parameter | Value |
| --------- | ----- |
| full name | `curated/09-aws-keys/compile-full` |
| model | [`compile`](MODELS.md#compile) |
| regex | `````(('\|")((?:ASIA\|AKIA\|AROA\|AIDA)([A-Z0-7]{16}))('\|").*?(\n^.*?){0,4}(('\|")[a-zA-Z0-9+/]{40}('\|"))+\|('\|")[a-zA-Z0-9+/]{40}('\|").*?(\n^.*?){0,3}('\|")((?:ASIA\|AKIA\|AROA\|AIDA)([A-Z0-7]{16}))('\|"))+````` |
| case-insensitive | `false` |
| unicode | `false` |
| haystack | `"AIDAABCDEFGHIJKLMNOP""aaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaa [.. snip ..]` |
| count | 1 |


**compile-quick**

| Parameter | Value |
| --------- | ----- |
| full name | `curated/09-aws-keys/compile-quick` |
| model | [`compile`](MODELS.md#compile) |
| regex | `````((?:ASIA\|AKIA\|AROA\|AIDA)([A-Z0-7]{16}))````` |
| case-insensitive | `false` |
| unicode | `false` |
| haystack | `AIDAABCDEFGHIJKLMNOP` |
| count | 1 |


</details>

#### bounded-repeat

This group of benchmarks measures how well regex engines do with bounded
repeats. Bounded repeats are sub-expressions that are permitted to match
up to some fixed number of times. For example, `a{3,5}` matches 3, 4 or 5
consecutive `a` characters. Unlike unbounded repetition operators, the regex
engine needs some way to track when the bound has reached its limit. For this
reason, many regex engines will translate `a{3,5}` to `aaaa?a?`. Given that
the bounds may be much higher than `5` and that the sub-expression may be much
more complicated than a single character, bounded repeats can quickly cause the
underlying matcher to balloon in size.

We measure three different types of bounded repeats:

* A search for a number of consecutive letters, both ASCII only and Unicode
aware.
* A search for certain types of words surrounding a `Result` type in Rust
source code.
* A search for consecutive words, all beginning with a capital letter.

We also include measurements for the compilation time of the last two.

Hyperscan does unusually well here, particularly for an automata oriented
engine. It's plausible that it has some specific optimizations in place for
bounded repeats.

`rust/regex` slows down quite a bit on the `context` regex. Namely, the
`context` regex is quite gnarly and its `(?s:.)` sub-expression coupled with
the bounded repeat causes a large portion of its transition table to get filled
out. This in turn results in more time than usual being spent actually building
the lazy DFA's transition table during a search. Typically, the lazy DFA's
transition table is built pretty quickly and then mostly reused on subsequent
searches. But in this case, the transition table exceeds the lazy DFA's cache
capacity and results in the cache getting cleared. However, the rate at which
new transitions are created is still low enough that the lazy DFA is used
instead of falling back to a slower engine.

| Engine | letters-en | letters-ru | context | capitals | compile-context | compile-capitals |
| - | - | - | - | - | - | - |
| dotnet/compiled | 257.3 MB/s | 191.4 MB/s | 332.5 MB/s | 866.2 MB/s | 33.50us | 28.69us |
| dotnet/nobacktrack | 146.0 MB/s | 110.9 MB/s | 53.4 MB/s | 552.8 MB/s | 200.63us | 48.59us |
| go/regexp | 29.5 MB/s | 27.5 MB/s | 29.3 MB/s | 52.6 MB/s | 74.82us | 54.98us |
| hyperscan | **733.8 MB/s** | 266.1 MB/s | **499.5 MB/s** | **2.6 GB/s** | 24.64ms | 664.52us |
| pcre2 | 70.8 MB/s | 415.9 KB/s | 29.8 MB/s | 555.0 MB/s | **4.41us** | **28.36us** |
| pcre2/jit | 333.4 MB/s | 285.1 MB/s | 323.9 MB/s | 1537.7 MB/s | 13.17us | 36.42us |
| perl | 69.5 MB/s | 49.9 MB/s | 88.2 MB/s | 217.7 MB/s | - | - |
| python/re | 73.0 MB/s | - | 72.4 MB/s | 66.4 MB/s | 57.77us | 32.01us |
| python/regex | 35.6 MB/s | 77.1 MB/s | 36.4 MB/s | 255.5 MB/s | 148.77us | 75.79us |
| re2 | 494.6 MB/s | 6.6 MB/s | 94.2 MB/s | 982.2 MB/s | 93.31us | 120.34us |
| regress | 168.3 MB/s | - | - | - | - | - |
| rust/regex | 621.6 MB/s | 538.8 MB/s | 20.2 MB/s | 810.4 MB/s | 42.00us | 63.75us |
| rust/regex/meta | 695.2 MB/s | **611.5 MB/s** | 102.5 MB/s | 825.6 MB/s | 61.35us | 61.81us |
| rust/regexold | 611.3 MB/s | 546.7 MB/s | 19.7 MB/s | 825.6 MB/s | 40.89us | 69.28us |

<details>
<summary>Show individual benchmark parameters.</summary>

**letters-en**

| Parameter | Value |
| --------- | ----- |
| full name | `curated/10-bounded-repeat/letters-en` |
| model | [`count`](MODELS.md#count) |
| regex | `````[A-Za-z]{8,13}````` |
| case-insensitive | `false` |
| unicode | `false` |
| haystack-path | [`opensubtitles/en-sampled.txt`](benchmarks/haystacks/opensubtitles/en-sampled.txt) |
| count(\*) | 1833 |
| count(hyperscan) | 3724 |


**letters-ru**

| Parameter | Value |
| --------- | ----- |
| full name | `curated/10-bounded-repeat/letters-ru` |
| model | [`count`](MODELS.md#count) |
| regex | `````\p{L}{8,13}````` |
| case-insensitive | `false` |
| unicode | `true` |
| haystack-path | [`opensubtitles/ru-sampled.txt`](benchmarks/haystacks/opensubtitles/ru-sampled.txt) |
| count(\*) | 3475 |
| count(hyperscan) | 8570 |


**context**

| Parameter | Value |
| --------- | ----- |
| full name | `curated/10-bounded-repeat/context` |
| model | [`count`](MODELS.md#count) |
| regex | `````[A-Za-z]{10}\s+(?s:.){0,100}Result(?s:.){0,100}\s+[A-Za-z]{10}````` |
| case-insensitive | `false` |
| unicode | `false` |
| haystack-path | [`rust-src-tools-3b0d4813.txt`](benchmarks/haystacks/rust-src-tools-3b0d4813.txt) |
| count(\*) | 53 |
| count(hyperscan) | 109 |


**capitals**

| Parameter | Value |
| --------- | ----- |
| full name | `curated/10-bounded-repeat/capitals` |
| model | [`count`](MODELS.md#count) |
| regex | `````(?:[A-Z][a-z]+\s*){10,100}````` |
| case-insensitive | `false` |
| unicode | `false` |
| haystack-path | [`rust-src-tools-3b0d4813.txt`](benchmarks/haystacks/rust-src-tools-3b0d4813.txt) |
| count(\*) | 11 |
| count(hyperscan) | 237 |


**compile-context**

| Parameter | Value |
| --------- | ----- |
| full name | `curated/10-bounded-repeat/compile-context` |
| model | [`compile`](MODELS.md#compile) |
| regex | `````[A-Za-z]{10}\s+(?s:.){0,100}Result(?s:.){0,100}\s+[A-Za-z]{10}````` |
| case-insensitive | `false` |
| unicode | `false` |
| haystack | `abcdefghij blah blah blah Result blib blab klmnopqrst` |
| count | 1 |


**compile-capitals**

| Parameter | Value |
| --------- | ----- |
| full name | `curated/10-bounded-repeat/compile-capitals` |
| model | [`compile`](MODELS.md#compile) |
| regex | `````(?:[A-Z][a-z]+\s*){10,100}````` |
| case-insensitive | `false` |
| unicode | `false` |
| haystack | `Crazy Janey Mission Man Wild Billy Greasy Lake Hazy Davy Kil [.. snip ..]` |
| count(\*) | 1 |
| count(hyperscan) | 12 |


</details>

#### unstructured-to-json

These benchmarks come from a [task that converts unstructured log data to
structured JSON data][OpatrilPeter description]. It works by iterating over
every line in the log file and parsing various parts of each line into
different sections using capture groups. The regex matches every line, so any
fast logic design to reject non-matches will generally penalize regex engines
here.

The original regex looks like this:

```
(?x)
^
(?P<timestamp>[^\ ]+\ [^\ ]+)

[\ ](?P<level>[DIWEF])[1234]:[\ ]

(?P<header>
    (?:
        (?:
            \[ [^\]]*? \] | \( [^\)]*? \)
        ):[\ ]
    )*
)

(?P<body>.*?)

[\ ]\{(?P<location>[^\}]*)\}
$
```

(The actual regex is flattened since not all engines support verbose mode. We
also remove the names from each capture group.)

`pcre2/jit` does _really_ well here. I'm not personally familiar with how
PCRE2's JIT works, but if I had to guess, I'd say there are some clever
optimizations with respect to the `[^ ]+` (and similar) sub-expressions in this
regex.

Otherwise, the backtracking engines generally outperform the automata engines
in this benchmark. Interestingly, all of `re2`, `go/regexp` and `rust/regex`
principally use their own bounded backtracking algorithms. But it looks like
"proper" backtrackers tend to be better optimized than the ones found in RE2
and its descendants. (Bounded backtracking does have to pay for checking that
no combination of haystack position and NFA state is visited more than once,
but even removing that check does not bring, e.g., `rust/regex` up to speeds
similar to other backtrackers.)

[OpatrilPeter description]: https://github.com/rust-lang/regex/discussions/960#discussioncomment-5106322

| Engine | extract | compile |
| - | - | - |
| dotnet/compiled | 560.1 MB/s | 44.75us |
| dotnet/nobacktrack | 17.7 MB/s | 505.07us |
| go/regexp | 82.7 MB/s | 21.23us |
| pcre2 | 206.9 MB/s | **1.35us** |
| pcre2/jit | **1440.3 MB/s** | 7.11us |
| perl | 147.5 MB/s | - |
| python/re | 119.9 MB/s | 88.83us |
| python/regex | 126.1 MB/s | 279.58us |
| re2 | 117.9 MB/s | 9.45us |
| regress | 301.1 MB/s | 4.01us |
| rust/regex | 89.9 MB/s | 17.27us |
| rust/regex/meta | 114.4 MB/s | 20.37us |
| rust/regexold | 89.5 MB/s | 14.05us |

<details>
<summary>Show individual benchmark parameters.</summary>

**extract**

| Parameter | Value |
| --------- | ----- |
| full name | `curated/11-unstructured-to-json/extract` |
| model | [`grep-captures`](MODELS.md#grep-captures) |
| regex-path | [`wild/unstructured-to-json.txt`](benchmarks/regexes/wild/unstructured-to-json.txt) |
| case-insensitive | `false` |
| unicode | `false` |
| haystack-path | [`wild/unstructured-to-json.log`](benchmarks/haystacks/wild/unstructured-to-json.log) |
| count | 600 |


**compile**

| Parameter | Value |
| --------- | ----- |
| full name | `curated/11-unstructured-to-json/compile` |
| model | [`compile`](MODELS.md#compile) |
| regex-path | [`wild/unstructured-to-json.txt`](benchmarks/regexes/wild/unstructured-to-json.txt) |
| case-insensitive | `false` |
| unicode | `false` |
| haystack | `2022/06/17 06:25:22 I4: [17936:140245395805952:(17998)]: (8f [.. snip ..]` |
| count | 1 |


</details>

### dictionary

#### compile

| Engine | english | english-10 | english-15 |
| - | - | - | - |
| go/regexp | - | 75.71ms | 13.52ms |
| re2 | - | 143.41ms | 3.77ms |
| regress | - | - | 2.86ms |
| rust/regex/ast | 56.17ms | 26.28ms | 1.23ms |
| rust/regex/hir | **39.06ms** | **15.19ms** | **862.64us** |
| rust/regex/meta | 177.64ms | 79.22ms | 7.86ms |
| rust/regex/nfa | 45.90ms | 18.47ms | 1.92ms |
| rust/regexold | 300.11ms | 141.51ms | 15.64ms |

<details>
<summary>Show individual benchmark parameters.</summary>

**english**

| Parameter | Value |
| --------- | ----- |
| full name | `dictionary/compile/english` |
| model | [`compile`](MODELS.md#compile) |
| regex-path | [`dictionary/english/sorted-by-length.txt`](benchmarks/regexes/dictionary/english/sorted-by-length.txt) |
| case-insensitive | `false` |
| unicode | `true` |
| haystack | `zygotes` |
| count | 1 |


**english-10**

| Parameter | Value |
| --------- | ----- |
| full name | `dictionary/compile/english-10` |
| model | [`compile`](MODELS.md#compile) |
| regex-path | [`dictionary/english/length-10.txt`](benchmarks/regexes/dictionary/english/length-10.txt) |
| case-insensitive | `false` |
| unicode | `true` |
| haystack | `Zubeneschamali's` |
| count | 1 |


**english-15**

| Parameter | Value |
| --------- | ----- |
| full name | `dictionary/compile/english-15` |
| model | [`compile`](MODELS.md#compile) |
| regex-path | [`dictionary/english/length-15.txt`](benchmarks/regexes/dictionary/english/length-15.txt) |
| case-insensitive | `false` |
| unicode | `true` |
| haystack | `Zubeneschamali's` |
| count | 1 |


</details>

#### search

| Engine | english | english-tiny | english-10 | english-15 |
| - | - | - | - | - |
| go/regexp | - | - | - | 569.0 KB/s |
| python/re | - | - | - | 174.6 KB/s |
| re2 | - | - | 137.8 KB/s | 5.7 MB/s |
| regress | - | - | - | 89.4 KB/s |
| rust/regex/meta | **102.9 MB/s** | 198.8 MB/s | **157.9 MB/s** | 717.2 MB/s |
| rust/regexold | 72.0 MB/s | **217.3 MB/s** | 84.4 MB/s | **736.3 MB/s** |

<details>
<summary>Show individual benchmark parameters.</summary>

**english**

| Parameter | Value |
| --------- | ----- |
| full name | `dictionary/search/english` |
| model | [`count-spans`](MODELS.md#count-spans) |
| regex-path | [`dictionary/english/sorted-by-length.txt`](benchmarks/regexes/dictionary/english/sorted-by-length.txt) |
| case-insensitive | `false` |
| unicode | `true` |
| haystack-path | [`opensubtitles/en-medium.txt`](benchmarks/haystacks/opensubtitles/en-medium.txt) |
| count | 45315 |


**english-tiny**

| Parameter | Value |
| --------- | ----- |
| full name | `dictionary/search/english-tiny` |
| model | [`count-spans`](MODELS.md#count-spans) |
| regex-path | [`dictionary/english/sorted-by-length.txt`](benchmarks/regexes/dictionary/english/sorted-by-length.txt) |
| case-insensitive | `false` |
| unicode | `true` |
| haystack-path | [`opensubtitles/en-tiny.txt`](benchmarks/haystacks/opensubtitles/en-tiny.txt) |
| count | 87 |


**english-10**

| Parameter | Value |
| --------- | ----- |
| full name | `dictionary/search/english-10` |
| model | [`count-spans`](MODELS.md#count-spans) |
| regex-path | [`dictionary/english/length-10.txt`](benchmarks/regexes/dictionary/english/length-10.txt) |
| case-insensitive | `false` |
| unicode | `true` |
| haystack-path | [`opensubtitles/en-medium.txt`](benchmarks/haystacks/opensubtitles/en-medium.txt) |
| count | 690 |


**english-15**

| Parameter | Value |
| --------- | ----- |
| full name | `dictionary/search/english-15` |
| model | [`count-spans`](MODELS.md#count-spans) |
| regex-path | [`dictionary/english/length-15.txt`](benchmarks/regexes/dictionary/english/length-15.txt) |
| case-insensitive | `false` |
| unicode | `true` |
| haystack-path | [`opensubtitles/en-medium.txt`](benchmarks/haystacks/opensubtitles/en-medium.txt) |
| count | 15 |


</details>

### folly

| Engine | awyer-inn-busted | literal-never-match-rare | literal-never-match-frequent | literal-never-match-tricksy |
| - | - | - | - | - |
| go/regexp | 61.5 MB/s | 57.3 GB/s | 3.0 GB/s | 4.5 GB/s |
| hyperscan | **21.9 GB/s** | 59.9 GB/s | **59.5 GB/s** | 10.1 GB/s |
| pcre2/jit | 895.0 MB/s | 45.6 GB/s | 36.8 GB/s | 2.4 GB/s |
| re2 | 985.2 MB/s | **82.2 GB/s** | 3.8 GB/s | 1494.4 MB/s |
| rust/memchr/memmem | - | 49.2 GB/s | 41.7 GB/s | **11.9 GB/s** |
| rust/regex/meta | 161.3 MB/s | 47.0 GB/s | 46.9 GB/s | 11.1 GB/s |

<details>
<summary>Show individual benchmark parameters.</summary>

**awyer-inn-busted**

| Parameter | Value |
| --------- | ----- |
| full name | `folly/awyer-inn-busted` |
| model | [`count`](MODELS.md#count) |
| regex | `````([A-Z]awyer\|[A-Z]inn)[0-9\s]````` |
| case-insensitive | `false` |
| unicode | `false` |
| haystack | `awyerinnawyerinnawyerinnawyerinnawyerinnawyerinnawyerinnawye [.. snip ..]` |
| count | 1 |


**literal-never-match-rare**

| Parameter | Value |
| --------- | ----- |
| full name | `folly/literal-never-match-rare` |
| model | [`count`](MODELS.md#count) |
| regex | `````ZQZQZQZQZQ````` |
| case-insensitive | `false` |
| unicode | `false` |
| haystack-path | [`rust-src-tools-3b0d4813.txt`](benchmarks/haystacks/rust-src-tools-3b0d4813.txt) |
| count | 0 |


**literal-never-match-frequent**

| Parameter | Value |
| --------- | ----- |
| full name | `folly/literal-never-match-frequent` |
| model | [`count`](MODELS.md#count) |
| regex | `````aeaeaeaeae````` |
| case-insensitive | `false` |
| unicode | `false` |
| haystack-path | [`rust-src-tools-3b0d4813.txt`](benchmarks/haystacks/rust-src-tools-3b0d4813.txt) |
| count | 0 |


**literal-never-match-tricksy**

| Parameter | Value |
| --------- | ----- |
| full name | `folly/literal-never-match-tricksy` |
| model | [`count`](MODELS.md#count) |
| regex | `````fooYbarZquux````` |
| case-insensitive | `false` |
| unicode | `false` |
| haystack | `fooYbarZquuffooYbarZquuffooYbarZquuffooYbarZquuffooYbarZquuf [.. snip ..]` |
| count | 1 |


</details>

### grep

| Engine | every-line | long-words-ascii | long-words-unicode |
| - | - | - | - |
| go/regexp | 792.2 MB/s | 73.6 MB/s | - |
| hyperscan | - | 725.3 MB/s | - |
| pcre2/jit | 1657.0 MB/s | 487.0 MB/s | 264.2 MB/s |
| python/re | 118.7 MB/s | - | - |
| python/regex | 98.5 MB/s | 64.1 MB/s | 70.7 MB/s |
| re2 | 955.6 MB/s | 486.4 MB/s | - |
| regress | 820.8 MB/s | 149.0 MB/s | - |
| rust/regex/hybrid | **2.4 GB/s** | - | - |
| rust/regex/meta | 1913.7 MB/s | **774.7 MB/s** | **732.8 MB/s** |
| rust/regexold | - | 739.8 MB/s | 3.8 MB/s |

<details>
<summary>Show individual benchmark parameters.</summary>

**every-line**

| Parameter | Value |
| --------- | ----- |
| full name | `grep/every-line` |
| model | [`grep`](MODELS.md#grep) |
| regex | `````````` |
| case-insensitive | `false` |
| unicode | `false` |
| haystack-path | [`rust-src-tools-3b0d4813.txt`](benchmarks/haystacks/rust-src-tools-3b0d4813.txt) |
| count | 239963 |


**long-words-ascii**

| Parameter | Value |
| --------- | ----- |
| full name | `grep/long-words-ascii` |
| model | [`grep`](MODELS.md#grep) |
| regex | `````\b\w{25,}\b````` |
| case-insensitive | `false` |
| unicode | `false` |
| haystack-path | [`rust-src-tools-3b0d4813.txt`](benchmarks/haystacks/rust-src-tools-3b0d4813.txt) |
| count | 5073 |


**long-words-unicode**

| Parameter | Value |
| --------- | ----- |
| full name | `grep/long-words-unicode` |
| model | [`grep`](MODELS.md#grep) |
| regex | `````\b\w{25,}\b````` |
| case-insensitive | `false` |
| unicode | `true` |
| haystack-path | [`rust-src-tools-3b0d4813.txt`](benchmarks/haystacks/rust-src-tools-3b0d4813.txt) |
| count | 5075 |


</details>

### hyperscan

| Engine | literal-english-nosom | literal-english-som | literal-casei-english-nosom | literal-casei-english-som | literal-russian-nosom | literal-russian-som | literal-casei-russian-nosom | literal-casei-russian-som | literal-suffix-nosom | literal-suffix-som | literal-inner-nosom | literal-inner-som | fixed-length-words-nosom | fixed-length-words-som | fixed-length-words-unicode-nosom |
| - | - | - | - | - | - | - | - | - | - | - | - | - | - | - | - |
| hyperscan | **54.8 GB/s** | **54.4 GB/s** | **51.2 GB/s** | **52.3 GB/s** | 5.5 GB/s | 5.4 GB/s | 10.8 GB/s | 10.7 GB/s | **28.2 GB/s** | 4.2 GB/s | 14.3 GB/s | 3.1 GB/s | **1366.2 MB/s** | **1366.5 MB/s** | 383.4 MB/s |
| rust/regex/meta | 41.0 GB/s | 41.5 GB/s | 17.4 GB/s | 17.4 GB/s | **41.5 GB/s** | **39.6 GB/s** | **13.5 GB/s** | **13.4 GB/s** | 20.1 GB/s | **17.7 GB/s** | **20.5 GB/s** | **19.7 GB/s** | 823.5 MB/s | 818.9 MB/s | **823.2 MB/s** |

<details>
<summary>Show individual benchmark parameters.</summary>

**literal-english-nosom**

| Parameter | Value |
| --------- | ----- |
| full name | `hyperscan/literal-english-nosom` |
| model | [`count`](MODELS.md#count) |
| regex | `````Sherlock Holmes````` |
| case-insensitive | `false` |
| unicode | `false` |
| haystack-path | [`opensubtitles/en-huge.txt`](benchmarks/haystacks/opensubtitles/en-huge.txt) |
| count | 1 |


**literal-english-som**

| Parameter | Value |
| --------- | ----- |
| full name | `hyperscan/literal-english-som` |
| model | [`count-spans`](MODELS.md#count-spans) |
| regex | `````Sherlock Holmes````` |
| case-insensitive | `false` |
| unicode | `false` |
| haystack-path | [`opensubtitles/en-huge.txt`](benchmarks/haystacks/opensubtitles/en-huge.txt) |
| count | 15 |


**literal-casei-english-nosom**

| Parameter | Value |
| --------- | ----- |
| full name | `hyperscan/literal-casei-english-nosom` |
| model | [`count`](MODELS.md#count) |
| regex | `````Sherlock Holmes````` |
| case-insensitive | `true` |
| unicode | `false` |
| haystack-path | [`opensubtitles/en-huge.txt`](benchmarks/haystacks/opensubtitles/en-huge.txt) |
| count | 1 |


**literal-casei-english-som**

| Parameter | Value |
| --------- | ----- |
| full name | `hyperscan/literal-casei-english-som` |
| model | [`count-spans`](MODELS.md#count-spans) |
| regex | `````Sherlock Holmes````` |
| case-insensitive | `true` |
| unicode | `false` |
| haystack-path | [`opensubtitles/en-huge.txt`](benchmarks/haystacks/opensubtitles/en-huge.txt) |
| count | 15 |


**literal-russian-nosom**

| Parameter | Value |
| --------- | ----- |
| full name | `hyperscan/literal-russian-nosom` |
| model | [`count`](MODELS.md#count) |
| regex | `````Шерлок Холмс````` |
| case-insensitive | `false` |
| unicode | `true` |
| haystack-path | [`opensubtitles/ru-huge.txt`](benchmarks/haystacks/opensubtitles/ru-huge.txt) |
| count | 1 |


**literal-russian-som**

| Parameter | Value |
| --------- | ----- |
| full name | `hyperscan/literal-russian-som` |
| model | [`count-spans`](MODELS.md#count-spans) |
| regex | `````Шерлок Холмс````` |
| case-insensitive | `false` |
| unicode | `true` |
| haystack-path | [`opensubtitles/ru-huge.txt`](benchmarks/haystacks/opensubtitles/ru-huge.txt) |
| count | 23 |


**literal-casei-russian-nosom**

| Parameter | Value |
| --------- | ----- |
| full name | `hyperscan/literal-casei-russian-nosom` |
| model | [`count`](MODELS.md#count) |
| regex | `````Шерлок Холмс````` |
| case-insensitive | `true` |
| unicode | `true` |
| haystack-path | [`opensubtitles/ru-huge.txt`](benchmarks/haystacks/opensubtitles/ru-huge.txt) |
| count | 1 |


**literal-casei-russian-som**

| Parameter | Value |
| --------- | ----- |
| full name | `hyperscan/literal-casei-russian-som` |
| model | [`count-spans`](MODELS.md#count-spans) |
| regex | `````Шерлок Холмс````` |
| case-insensitive | `true` |
| unicode | `true` |
| haystack-path | [`opensubtitles/ru-huge.txt`](benchmarks/haystacks/opensubtitles/ru-huge.txt) |
| count | 23 |


**literal-suffix-nosom**

| Parameter | Value |
| --------- | ----- |
| full name | `hyperscan/literal-suffix-nosom` |
| model | [`count`](MODELS.md#count) |
| regex | `````\w+\s+Holmes````` |
| case-insensitive | `false` |
| unicode | `false` |
| haystack-path | [`sherlock.txt`](benchmarks/haystacks/sherlock.txt) |
| count | 319 |


**literal-suffix-som**

| Parameter | Value |
| --------- | ----- |
| full name | `hyperscan/literal-suffix-som` |
| model | [`count-spans`](MODELS.md#count-spans) |
| regex | `````\w+\s+Holmes````` |
| case-insensitive | `false` |
| unicode | `false` |
| haystack-path | [`sherlock.txt`](benchmarks/haystacks/sherlock.txt) |
| count | 4073 |


**literal-inner-nosom**

| Parameter | Value |
| --------- | ----- |
| full name | `hyperscan/literal-inner-nosom` |
| model | [`count`](MODELS.md#count) |
| regex | `````\b\w+\s+Holmes\s+\w+\b````` |
| case-insensitive | `false` |
| unicode | `false` |
| haystack-path | [`sherlock.txt`](benchmarks/haystacks/sherlock.txt) |
| count | 137 |


**literal-inner-som**

| Parameter | Value |
| --------- | ----- |
| full name | `hyperscan/literal-inner-som` |
| model | [`count-spans`](MODELS.md#count-spans) |
| regex | `````\b\w+\s+Holmes\s+\w+\b````` |
| case-insensitive | `false` |
| unicode | `false` |
| haystack-path | [`sherlock.txt`](benchmarks/haystacks/sherlock.txt) |
| count | 2593 |


**fixed-length-words-nosom**

| Parameter | Value |
| --------- | ----- |
| full name | `hyperscan/fixed-length-words-nosom` |
| model | [`count`](MODELS.md#count) |
| regex | `````\w{5}\s\w{6}\s\w{7}````` |
| case-insensitive | `false` |
| unicode | `false` |
| haystack-path | [`sherlock.txt`](benchmarks/haystacks/sherlock.txt) |
| count | 120 |


**fixed-length-words-som**

| Parameter | Value |
| --------- | ----- |
| full name | `hyperscan/fixed-length-words-som` |
| model | [`count-spans`](MODELS.md#count-spans) |
| regex | `````\w{5}\s\w{6}\s\w{7}````` |
| case-insensitive | `false` |
| unicode | `false` |
| haystack-path | [`sherlock.txt`](benchmarks/haystacks/sherlock.txt) |
| count | 2400 |


**fixed-length-words-unicode-nosom**

| Parameter | Value |
| --------- | ----- |
| full name | `hyperscan/fixed-length-words-unicode-nosom` |
| model | [`count`](MODELS.md#count) |
| regex | `````\w{5}\s\w{6}\s\w{7}````` |
| case-insensitive | `false` |
| unicode | `true` |
| haystack-path | [`sherlock.txt`](benchmarks/haystacks/sherlock.txt) |
| count | 120 |


</details>

### imported

#### leipzig

| Engine | twain | twain-insensitive | shing | huck-saw | word-ending-nn | certain-long-strings-ending-x | tom-sawyer-huckle-finn | tom-sawyer-huckle-fin-insensitive | tom-sawyer-huckle-fin-prefix-short | tom-sawyer-huckle-fin-prefix-long | tom-river | ing | ing-whitespace | awyer-inn | quotes-bounded | non-ascii-alternate | math-symbols | bounded-strings-ending-z |
| - | - | - | - | - | - | - | - | - | - | - | - | - | - | - | - | - | - | - |
| go/regexp | 17.2 GB/s | 62.3 MB/s | 51.0 MB/s | 48.2 MB/s | 34.4 MB/s | 15.6 MB/s | 24.9 MB/s | 14.8 MB/s | 15.3 MB/s | 13.4 MB/s | 45.8 MB/s | 40.6 MB/s | 29.2 MB/s | 31.0 MB/s | 55.0 MB/s | 80.5 MB/s | 48.5 MB/s | 32.7 MB/s |
| pcre2 | 12.3 GB/s | 595.4 MB/s | 80.8 MB/s | 1996.4 MB/s | 53.9 MB/s | 62.3 MB/s | 1460.0 MB/s | 115.1 MB/s | 12.1 MB/s | 11.7 MB/s | 625.1 MB/s | 33.8 MB/s | 77.6 MB/s | 33.1 MB/s | 649.6 MB/s | 2.3 GB/s | 34.2 MB/s | 87.6 MB/s |
| pcre2/jit | **40.8 GB/s** | **30.0 GB/s** | 18.4 GB/s | 21.7 GB/s | 366.1 MB/s | 211.4 MB/s | 1498.7 MB/s | 460.1 MB/s | 193.6 MB/s | 172.2 MB/s | 8.5 GB/s | 432.9 MB/s | 341.2 MB/s | 2.1 GB/s | **4.0 GB/s** | 32.6 GB/s | 757.9 MB/s | 839.6 MB/s |
| python/re | 4.3 GB/s | 275.5 MB/s | 141.8 MB/s | 476.7 MB/s | 93.3 MB/s | 50.1 MB/s | 498.1 MB/s | 52.7 MB/s | 36.4 MB/s | 37.1 MB/s | 346.5 MB/s | 65.2 MB/s | 101.9 MB/s | 81.4 MB/s | 321.9 MB/s | 493.0 MB/s | - | 4.1 MB/s |
| python/regex | 1706.4 MB/s | 1536.4 MB/s | 1372.2 MB/s | 424.0 MB/s | 42.5 MB/s | 2.2 GB/s | 350.6 MB/s | 64.2 MB/s | 10.2 MB/s | 10.0 MB/s | 266.4 MB/s | 23.4 MB/s | 429.8 MB/s | 35.3 MB/s | 269.6 MB/s | 434.4 MB/s | 533.8 MB/s | 4.2 MB/s |
| re2 | 23.5 GB/s | 2.9 GB/s | 981.5 MB/s | 984.7 MB/s | 987.2 MB/s | 298.2 MB/s | 975.9 MB/s | 950.9 MB/s | 975.9 MB/s | 979.0 MB/s | 982.1 MB/s | 700.9 MB/s | 761.3 MB/s | 986.6 MB/s | 937.5 MB/s | 986.6 MB/s | **981.5 MB/s** | 985.9 MB/s |
| regress | 3.6 GB/s | 2.3 GB/s | 201.1 MB/s | 15.9 GB/s | 125.1 MB/s | 68.6 MB/s | 2.3 GB/s | 210.4 MB/s | 31.0 MB/s | 30.4 MB/s | 2.3 GB/s | 88.6 MB/s | 163.2 MB/s | 120.7 MB/s | 1308.7 MB/s | **86.5 GB/s** | - | 8.3 MB/s |
| rust/regex | 38.7 GB/s | 21.3 GB/s | 27.8 GB/s | **22.3 GB/s** | 825.1 MB/s | 445.1 MB/s | **20.5 GB/s** | 801.7 MB/s | 821.1 MB/s | 822.0 MB/s | 15.4 GB/s | 3.2 GB/s | 540.8 MB/s | 825.1 MB/s | 3.3 GB/s | 19.3 GB/s | 826.0 MB/s | 825.5 MB/s |
| rust/regex/meta | 39.3 GB/s | 16.3 GB/s | **28.2 GB/s** | 22.2 GB/s | **31.1 GB/s** | **5.6 GB/s** | 17.1 GB/s | **1215.9 MB/s** | **19.0 GB/s** | **18.2 GB/s** | **16.6 GB/s** | 3.1 GB/s | **2.9 GB/s** | **13.4 GB/s** | 3.9 GB/s | 23.0 GB/s | 826.0 MB/s | **48.3 GB/s** |
| rust/regexold | 38.8 GB/s | 21.2 GB/s | 28.1 GB/s | 18.7 GB/s | 825.1 MB/s | 444.9 MB/s | 17.5 GB/s | 772.5 MB/s | 821.1 MB/s | 822.9 MB/s | 14.1 GB/s | **3.2 GB/s** | 549.0 MB/s | 825.1 MB/s | 3.4 GB/s | 22.7 GB/s | 826.0 MB/s | 825.5 MB/s |

<details>
<summary>Show individual benchmark parameters.</summary>

**twain**

| Parameter | Value |
| --------- | ----- |
| full name | `imported/leipzig/twain` |
| model | [`count-spans`](MODELS.md#count-spans) |
| regex | `````Twain````` |
| case-insensitive | `false` |
| unicode | `false` |
| haystack-path | [`imported/leipzig-3200.txt`](benchmarks/haystacks/imported/leipzig-3200.txt) |
| count | 4055 |


**twain-insensitive**

| Parameter | Value |
| --------- | ----- |
| full name | `imported/leipzig/twain-insensitive` |
| model | [`count-spans`](MODELS.md#count-spans) |
| regex | `````Twain````` |
| case-insensitive | `true` |
| unicode | `false` |
| haystack-path | [`imported/leipzig-3200.txt`](benchmarks/haystacks/imported/leipzig-3200.txt) |
| count | 4825 |


**shing**

| Parameter | Value |
| --------- | ----- |
| full name | `imported/leipzig/shing` |
| model | [`count-spans`](MODELS.md#count-spans) |
| regex | `````[a-z]shing````` |
| case-insensitive | `false` |
| unicode | `false` |
| haystack-path | [`imported/leipzig-3200.txt`](benchmarks/haystacks/imported/leipzig-3200.txt) |
| count | 9240 |


**huck-saw**

| Parameter | Value |
| --------- | ----- |
| full name | `imported/leipzig/huck-saw` |
| model | [`count-spans`](MODELS.md#count-spans) |
| regex | `````Huck[a-zA-Z]+\|Saw[a-zA-Z]+````` |
| case-insensitive | `false` |
| unicode | `false` |
| haystack-path | [`imported/leipzig-3200.txt`](benchmarks/haystacks/imported/leipzig-3200.txt) |
| count | 1819 |


**word-ending-nn**

| Parameter | Value |
| --------- | ----- |
| full name | `imported/leipzig/word-ending-nn` |
| model | [`count-spans`](MODELS.md#count-spans) |
| regex | `````\b\w+nn\b````` |
| case-insensitive | `false` |
| unicode | `false` |
| haystack-path | [`imported/leipzig-3200.txt`](benchmarks/haystacks/imported/leipzig-3200.txt) |
| count | 1105 |


**certain-long-strings-ending-x**

| Parameter | Value |
| --------- | ----- |
| full name | `imported/leipzig/certain-long-strings-ending-x` |
| model | [`count-spans`](MODELS.md#count-spans) |
| regex | `````[a-q][^u-z]{13}x````` |
| case-insensitive | `false` |
| unicode | `false` |
| haystack-path | [`imported/leipzig-3200.txt`](benchmarks/haystacks/imported/leipzig-3200.txt) |
| count | 61410 |


**tom-sawyer-huckle-finn**

| Parameter | Value |
| --------- | ----- |
| full name | `imported/leipzig/tom-sawyer-huckle-finn` |
| model | [`count-spans`](MODELS.md#count-spans) |
| regex | `````Tom\|Sawyer\|Huckleberry\|Finn````` |
| case-insensitive | `false` |
| unicode | `false` |
| haystack-path | [`imported/leipzig-3200.txt`](benchmarks/haystacks/imported/leipzig-3200.txt) |
| count | 8878 |


**tom-sawyer-huckle-fin-insensitive**

| Parameter | Value |
| --------- | ----- |
| full name | `imported/leipzig/tom-sawyer-huckle-fin-insensitive` |
| model | [`count-spans`](MODELS.md#count-spans) |
| regex | `````Tom\|Sawyer\|Huckleberry\|Finn````` |
| case-insensitive | `true` |
| unicode | `false` |
| haystack-path | [`imported/leipzig-3200.txt`](benchmarks/haystacks/imported/leipzig-3200.txt) |
| count | 13668 |


**tom-sawyer-huckle-fin-prefix-short**

| Parameter | Value |
| --------- | ----- |
| full name | `imported/leipzig/tom-sawyer-huckle-fin-prefix-short` |
| model | [`count-spans`](MODELS.md#count-spans) |
| regex | `````.{0,2}(Tom\|Sawyer\|Huckleberry\|Finn)````` |
| case-insensitive | `false` |
| unicode | `false` |
| haystack-path | [`imported/leipzig-3200.txt`](benchmarks/haystacks/imported/leipzig-3200.txt) |
| count | 13024 |


**tom-sawyer-huckle-fin-prefix-long**

| Parameter | Value |
| --------- | ----- |
| full name | `imported/leipzig/tom-sawyer-huckle-fin-prefix-long` |
| model | [`count-spans`](MODELS.md#count-spans) |
| regex | `````.{2,4}(Tom\|Sawyer\|Huckleberry\|Finn)````` |
| case-insensitive | `false` |
| unicode | `false` |
| haystack-path | [`imported/leipzig-3200.txt`](benchmarks/haystacks/imported/leipzig-3200.txt) |
| count | 14298 |


**tom-river**

| Parameter | Value |
| --------- | ----- |
| full name | `imported/leipzig/tom-river` |
| model | [`count-spans`](MODELS.md#count-spans) |
| regex | `````Tom.{10,25}river\|river.{10,25}Tom````` |
| case-insensitive | `false` |
| unicode | `false` |
| haystack-path | [`imported/leipzig-3200.txt`](benchmarks/haystacks/imported/leipzig-3200.txt) |
| count | 37 |


**ing**

| Parameter | Value |
| --------- | ----- |
| full name | `imported/leipzig/ing` |
| model | [`count-spans`](MODELS.md#count-spans) |
| regex | `````[a-zA-Z]+ing````` |
| case-insensitive | `false` |
| unicode | `false` |
| haystack-path | [`imported/leipzig-3200.txt`](benchmarks/haystacks/imported/leipzig-3200.txt) |
| count | 571241 |


**ing-whitespace**

| Parameter | Value |
| --------- | ----- |
| full name | `imported/leipzig/ing-whitespace` |
| model | [`count-spans`](MODELS.md#count-spans) |
| regex | `````\s[a-zA-Z]{0,12}ing\s````` |
| case-insensitive | `false` |
| unicode | `false` |
| haystack-path | [`imported/leipzig-3200.txt`](benchmarks/haystacks/imported/leipzig-3200.txt) |
| count | 521534 |


**awyer-inn**

| Parameter | Value |
| --------- | ----- |
| full name | `imported/leipzig/awyer-inn` |
| model | [`count-spans`](MODELS.md#count-spans) |
| regex | `````([A-Za-z]awyer\|[A-Za-z]inn)\s````` |
| case-insensitive | `false` |
| unicode | `false` |
| haystack-path | [`imported/leipzig-3200.txt`](benchmarks/haystacks/imported/leipzig-3200.txt) |
| count | 1397 |


**quotes-bounded**

| Parameter | Value |
| --------- | ----- |
| full name | `imported/leipzig/quotes-bounded` |
| model | [`count-spans`](MODELS.md#count-spans) |
| regex | `````["'][^"']{0,30}[?!\.]["']````` |
| case-insensitive | `false` |
| unicode | `false` |
| haystack-path | [`imported/leipzig-3200.txt`](benchmarks/haystacks/imported/leipzig-3200.txt) |
| count | 160586 |


**non-ascii-alternate**

| Parameter | Value |
| --------- | ----- |
| full name | `imported/leipzig/non-ascii-alternate` |
| model | [`count-spans`](MODELS.md#count-spans) |
| regex | `````∞\|✓````` |
| case-insensitive | `false` |
| unicode | `true` |
| haystack-path | [`imported/leipzig-3200.txt`](benchmarks/haystacks/imported/leipzig-3200.txt) |
| count | 6 |


**math-symbols**

| Parameter | Value |
| --------- | ----- |
| full name | `imported/leipzig/math-symbols` |
| model | [`count-spans`](MODELS.md#count-spans) |
| regex | `````\p{Sm}````` |
| case-insensitive | `false` |
| unicode | `true` |
| haystack-path | [`imported/leipzig-3200.txt`](benchmarks/haystacks/imported/leipzig-3200.txt) |
| count | 71 |


**bounded-strings-ending-z**

| Parameter | Value |
| --------- | ----- |
| full name | `imported/leipzig/bounded-strings-ending-z` |
| model | [`count-spans`](MODELS.md#count-spans) |
| regex | `````(.*?,){13}z````` |
| case-insensitive | `false` |
| unicode | `false` |
| haystack-path | [`imported/leipzig-3200.txt`](benchmarks/haystacks/imported/leipzig-3200.txt) |
| count | 0 |


</details>

#### lh3lh3-reb

| Engine | uri | email | date | uri-or-email |
| - | - | - | - | - |
| go/regexp | 43.6 MB/s | 46.8 MB/s | 80.4 MB/s | 22.0 MB/s |
| pcre2 | 552.6 MB/s | 1151.8 MB/s | 947.0 MB/s | 28.3 MB/s |
| pcre2/jit | 1171.2 MB/s | 1648.2 MB/s | 1184.1 MB/s | 228.0 MB/s |
| python/re | 35.5 MB/s | 20.7 MB/s | 100.8 MB/s | 13.4 MB/s |
| python/regex | 116.9 MB/s | 112.5 MB/s | 119.2 MB/s | 7.8 MB/s |
| re2 | 518.9 MB/s | 514.3 MB/s | 505.9 MB/s | 517.8 MB/s |
| rust/regex | 792.0 MB/s | 785.7 MB/s | 723.8 MB/s | 792.5 MB/s |
| rust/regex/meta | **2.2 GB/s** | **2.6 GB/s** | **2.1 GB/s** | 723.6 MB/s |
| rust/regexold | 801.3 MB/s | 793.7 MB/s | 663.4 MB/s | **799.9 MB/s** |

<details>
<summary>Show individual benchmark parameters.</summary>

**uri**

| Parameter | Value |
| --------- | ----- |
| full name | `imported/lh3lh3-reb/uri` |
| model | [`grep`](MODELS.md#grep) |
| regex | `````([a-zA-Z][a-zA-Z0-9]*)://([^ /]+)(/[^ ]*)?````` |
| case-insensitive | `false` |
| unicode | `false` |
| haystack-path | [`imported/lh3lh3-reb-howto.txt`](benchmarks/haystacks/imported/lh3lh3-reb-howto.txt) |
| count | 17549 |


**email**

| Parameter | Value |
| --------- | ----- |
| full name | `imported/lh3lh3-reb/email` |
| model | [`grep`](MODELS.md#grep) |
| regex | `````([^ @]+)@([^ @]+)````` |
| case-insensitive | `false` |
| unicode | `false` |
| haystack-path | [`imported/lh3lh3-reb-howto.txt`](benchmarks/haystacks/imported/lh3lh3-reb-howto.txt) |
| count | 15057 |


**date**

| Parameter | Value |
| --------- | ----- |
| full name | `imported/lh3lh3-reb/date` |
| model | [`grep`](MODELS.md#grep) |
| regex | `````([0-9][0-9]?)/([0-9][0-9]?)/([0-9][0-9]([0-9][0-9])?)````` |
| case-insensitive | `false` |
| unicode | `false` |
| haystack-path | [`imported/lh3lh3-reb-howto.txt`](benchmarks/haystacks/imported/lh3lh3-reb-howto.txt) |
| count | 668 |


**uri-or-email**

| Parameter | Value |
| --------- | ----- |
| full name | `imported/lh3lh3-reb/uri-or-email` |
| model | [`grep`](MODELS.md#grep) |
| regex | `````([a-zA-Z][a-zA-Z0-9]*)://([^ /]+)(/[^ ]*)?\|([^ @]+)@([^ @]+)````` |
| case-insensitive | `false` |
| unicode | `false` |
| haystack-path | [`imported/lh3lh3-reb-howto.txt`](benchmarks/haystacks/imported/lh3lh3-reb-howto.txt) |
| count | 32539 |


</details>

#### mariomka

| Engine | email | uri | ip |
| - | - | - | - |
| go/regexp | 46.4 MB/s | 46.8 MB/s | 30.3 MB/s |
| pcre2 | 87.4 MB/s | 94.9 MB/s | 772.8 MB/s |
| pcre2/jit | 496.8 MB/s | 487.5 MB/s | 2.5 GB/s |
| python/re | 46.3 MB/s | 76.8 MB/s | 40.9 MB/s |
| python/regex | 20.2 MB/s | 33.7 MB/s | 762.9 MB/s |
| re2 | 986.8 MB/s | 889.8 MB/s | 982.3 MB/s |
| regress | 96.8 MB/s | 106.1 MB/s | 114.2 MB/s |
| rust/regex | 825.6 MB/s | 762.9 MB/s | 716.0 MB/s |
| rust/regex/meta | **51.2 GB/s** | **7.8 GB/s** | 3.0 GB/s |
| rust/regexold | 825.6 MB/s | 764.7 MB/s | **3.1 GB/s** |

<details>
<summary>Show individual benchmark parameters.</summary>

**email**

| Parameter | Value |
| --------- | ----- |
| full name | `imported/mariomka/email` |
| model | [`count-spans`](MODELS.md#count-spans) |
| regex | `````[\w\.+-]+@[\w\.-]+\.[\w\.-]+````` |
| case-insensitive | `false` |
| unicode | `false` |
| haystack-path | [`imported/mariomka.txt`](benchmarks/haystacks/imported/mariomka.txt) |
| count | 1636 |


**uri**

| Parameter | Value |
| --------- | ----- |
| full name | `imported/mariomka/uri` |
| model | [`count-spans`](MODELS.md#count-spans) |
| regex | `````[\w]+://[^/\s?#]+[^\s?#]+(?:\?[^\s#]*)?(?:#[^\s]*)?````` |
| case-insensitive | `false` |
| unicode | `false` |
| haystack-path | [`imported/mariomka.txt`](benchmarks/haystacks/imported/mariomka.txt) |
| count | 215980 |


**ip**

| Parameter | Value |
| --------- | ----- |
| full name | `imported/mariomka/ip` |
| model | [`count-spans`](MODELS.md#count-spans) |
| regex | `````(?:(?:25[0-5]\|2[0-4][0-9]\|[01]?[0-9][0-9])\.){3}(?:25[0-5]\|2[0-4][0-9]\|[01]?[0-9][0-9])````` |
| case-insensitive | `false` |
| unicode | `false` |
| haystack-path | [`imported/mariomka.txt`](benchmarks/haystacks/imported/mariomka.txt) |
| count | 61 |


</details>

#### regex-redux

| Engine | regex-redux |
| - | - |
| dotnet | 228.88ms |
| dotnet/compiled | 62.38ms |
| dotnet/nobacktrack | 65.40ms |
| go/regexp | 408.44ms |
| hyperscan | 77.09ms |
| pcre2 | 160.75ms |
| pcre2/jit | 20.95ms |
| perl | 151.93ms |
| python/re | 135.61ms |
| python/regex | 202.90ms |
| re2 | 30.63ms |
| regress | 60.20ms |
| rust/regex | 15.44ms |
| rust/regex/meta | **12.18ms** |
| rust/regexold | 15.01ms |

<details>
<summary>Show individual benchmark parameters.</summary>

**regex-redux**

| Parameter | Value |
| --------- | ----- |
| full name | `imported/regex-redux/regex-redux` |
| model | [`regex-redux`](MODELS.md#regex-redux) |
| regex | NONE |
| case-insensitive | `false` |
| unicode | `false` |
| haystack-path | [`imported/regex-redux-100000.fasta`](benchmarks/haystacks/imported/regex-redux-100000.fasta) |
| count | 547899 |


</details>

#### rsc

| Engine | no-exponential | literal | not-literal | match-class | match-class-in-range | match-class-unicode | anchored-literal-short-non-match | anchored-literal-long-non-match | anchored-literal-short-match | anchored-literal-long-match | one-pass-short | one-pass-short-not | one-pass-long-prefix | one-pass-long-prefix-not | long-needle1 | long-needle2 | easy0-32 | easy0-1k | easy0-32k | easy0-1mb | easy1-32 | easy1-1k | easy1-32k | easy1-1mb | medium-32 | medium-1k | medium-32k | medium-1mb | hard-32 | hard-1k | hard-32k | hard-1mb | reallyhard0-32 | reallyhard0-1k | reallyhard0-32k | reallyhard0-1mb | reallyreallyhard0-32 | reallyreallyhard0-1k | reallyreallyhard0-32k | reallyreallyhard0-1mb | reallyreallyreallyhard0-32 | reallyreallyreallyhard0-1k | reallyreallyreallyhard0-32k | reallyreallyreallyhard0-1mb |
| - | - | - | - | - | - | - | - | - | - | - | - | - | - | - | - | - | - | - | - | - | - | - | - | - | - | - | - | - | - | - | - | - | - | - | - | - | - | - | - | - | - | - | - | - |
| go/regexp | 34.1 MB/s | 386.0 MB/s | 87.6 MB/s | 96.9 MB/s | 105.7 MB/s | 103.7 MB/s | 590.4 MB/s | 8.4 GB/s | 213.8 MB/s | 3.1 GB/s | 63.1 MB/s | 49.6 MB/s | 195.2 MB/s | 139.3 MB/s | 5.6 MB/s | 5.6 MB/s | 291.1 MB/s | 4.3 GB/s | 30.9 GB/s | 65.2 GB/s | 260.1 MB/s | 4.4 GB/s | 33.4 GB/s | 55.6 GB/s | 129.3 MB/s | 126.2 MB/s | 78.0 MB/s | 78.0 MB/s | 78.2 MB/s | 65.7 MB/s | 44.4 MB/s | 43.7 MB/s | 78.1 MB/s | 66.2 MB/s | 45.1 MB/s | 43.9 MB/s | 95.0 MB/s | 50.1 MB/s | 36.1 MB/s | 35.8 MB/s | 93.0 MB/s | 50.4 MB/s | 36.1 MB/s | 35.8 MB/s |
| pcre2 | 19 B/s | 935.3 MB/s | 66.3 MB/s | 887.9 MB/s | 887.9 MB/s | 92.5 MB/s | 1180.7 MB/s | 17.3 GB/s | 326.3 MB/s | 4.9 GB/s | 66.7 MB/s | 65.4 MB/s | 278.6 MB/s | 281.8 MB/s | 19.9 MB/s | 20.1 MB/s | 674.6 MB/s | 11.5 GB/s | **120.7 GB/s** | **117.5 GB/s** | 559.1 MB/s | 10.7 GB/s | 117.4 GB/s | 117.1 GB/s | 598.6 MB/s | 2.2 GB/s | 2.7 GB/s | 2.7 GB/s | 200.4 MB/s | 7.5 MB/s | 7.0 MB/s | 6.8 MB/s | 194.8 MB/s | 7.5 MB/s | 7.0 MB/s | 7.0 MB/s | 560.3 MB/s | 36.0 MB/s | 34.3 MB/s | 31.7 MB/s | 481.6 MB/s | 36.2 MB/s | 34.1 MB/s | 31.7 MB/s |
| pcre2/jit | 157 B/s | 1519.9 MB/s | **1430.5 MB/s** | 1404.5 MB/s | 2.3 GB/s | **783.4 MB/s** | 1239.8 MB/s | 18.2 GB/s | **774.9 MB/s** | 8.4 GB/s | **405.3 MB/s** | 368.5 MB/s | **799.9 MB/s** | **799.9 MB/s** | 328.3 MB/s | 328.3 MB/s | 1626.9 MB/s | 15.0 GB/s | 43.7 GB/s | 46.2 GB/s | **1314.5 MB/s** | 14.9 GB/s | 43.6 GB/s | 46.2 GB/s | 1250.4 MB/s | 15.5 GB/s | 43.7 GB/s | 46.2 GB/s | **1005.7 MB/s** | 1871.7 MB/s | 1690.5 MB/s | 1294.0 MB/s | **987.7 MB/s** | 1827.3 MB/s | 1688.7 MB/s | 1304.2 MB/s | **878.9 MB/s** | 1811.5 MB/s | 1367.6 MB/s | 1144.8 MB/s | **935.3 MB/s** | 1859.2 MB/s | 1496.1 MB/s | 1176.0 MB/s |
| python/re | 18 B/s | 113.6 MB/s | 76.6 MB/s | 115.3 MB/s | 114.6 MB/s | - | 56.5 MB/s | 244.7 MB/s | 44.3 MB/s | 228.2 MB/s | 22.6 MB/s | 22.5 MB/s | 46.7 MB/s | 47.2 MB/s | 704.5 MB/s | **705.5 MB/s** | 122.4 MB/s | 1508.1 MB/s | 4.5 GB/s | 4.8 GB/s | 97.7 MB/s | 1395.1 MB/s | 4.4 GB/s | 4.8 GB/s | 95.2 MB/s | 364.5 MB/s | 450.6 MB/s | 448.4 MB/s | 97.6 MB/s | 31.6 MB/s | 29.8 MB/s | 29.8 MB/s | 96.4 MB/s | 31.7 MB/s | 29.8 MB/s | 29.8 MB/s | 84.9 MB/s | 6.7 MB/s | 6.4 MB/s | 6.4 MB/s | 88.3 MB/s | 6.8 MB/s | 6.4 MB/s | 6.4 MB/s |
| python/regex | 725.3 KB/s | 103.5 MB/s | 103.0 MB/s | 112.4 MB/s | 113.8 MB/s | 232.3 MB/s | 72.3 MB/s | 1036.0 MB/s | 48.5 MB/s | 726.4 MB/s | 13.7 MB/s | 13.7 MB/s | 52.0 MB/s | 52.8 MB/s | 448.9 MB/s | 448.9 MB/s | 118.2 MB/s | 1834.0 MB/s | 9.5 GB/s | 11.3 GB/s | 91.1 MB/s | 1336.9 MB/s | 4.4 GB/s | 4.8 GB/s | 112.8 MB/s | 1774.0 MB/s | 9.1 GB/s | 11.3 GB/s | 101.7 MB/s | 259.4 MB/s | 247.6 MB/s | 245.1 MB/s | 100.8 MB/s | 254.8 MB/s | 243.2 MB/s | 241.0 MB/s | 72.5 MB/s | 5.8 MB/s | 5.4 MB/s | 5.5 MB/s | 72.7 MB/s | 5.7 MB/s | 5.4 MB/s | 5.4 MB/s |
| re2 | 384.5 MB/s | 481.6 MB/s | 337.8 MB/s | 449.1 MB/s | 449.1 MB/s | 616.6 MB/s | **1458.6 MB/s** | **21.4 GB/s** | 486.2 MB/s | 7.1 GB/s | 257.3 MB/s | 176.2 MB/s | 506.0 MB/s | 335.1 MB/s | 253.6 MB/s | 253.6 MB/s | 354.6 MB/s | 6.0 GB/s | 87.0 GB/s | 110.7 GB/s | 517.4 MB/s | 10.3 GB/s | 324.8 GB/s | 10389.2 GB/s | 546.3 MB/s | 9.6 GB/s | 299.4 GB/s | 9574.4 GB/s | 400.8 MB/s | 9.6 GB/s | 299.4 GB/s | 7812.7 GB/s | 265.9 MB/s | 886.2 MB/s | 985.7 MB/s | 990.1 MB/s | 250.4 MB/s | 900.8 MB/s | 988.4 MB/s | 990.1 MB/s | 239.6 MB/s | 880.2 MB/s | 987.9 MB/s | 990.1 MB/s |
| regress | 33 B/s | 1279.9 MB/s | 257.3 MB/s | 1355.2 MB/s | 1980.7 MB/s | - | 269.5 MB/s | 399.1 MB/s | 206.6 MB/s | 387.4 MB/s | 70.5 MB/s | 69.9 MB/s | 619.9 MB/s | 604.8 MB/s | 261.2 MB/s | 261.2 MB/s | 1229.2 MB/s | 3.2 GB/s | 3.6 GB/s | 3.6 GB/s | 1034.8 MB/s | 18.3 GB/s | 133.3 GB/s | 120.7 GB/s | 1250.4 MB/s | 2.9 GB/s | 3.2 GB/s | 3.2 GB/s | 406.7 MB/s | 20.8 MB/s | 19.4 MB/s | 19.5 MB/s | 409.7 MB/s | 19.7 MB/s | 19.4 MB/s | 19.4 MB/s | 521.2 MB/s | 8.8 MB/s | 8.0 MB/s | 8.2 MB/s | 501.4 MB/s | 8.9 MB/s | 8.2 MB/s | 8.2 MB/s |
| rust/regex/meta | 449.8 MB/s | **2.5 GB/s** | 1279.9 MB/s | **2.3 GB/s** | **3.8 GB/s** | 691.6 MB/s | 1033.1 MB/s | 15.1 GB/s | 688.8 MB/s | **10.1 GB/s** | 324.2 MB/s | **377.0 MB/s** | 413.3 MB/s | 413.3 MB/s | **50.9 GB/s** | 488.4 MB/s | **2.3 GB/s** | **26.4 GB/s** | 72.0 GB/s | 41.9 GB/s | 1034.8 MB/s | **20.7 GB/s** | **649.7 GB/s** | **20778.3 GB/s** | 937.8 MB/s | 16.3 GB/s | 517.7 GB/s | 16276.5 GB/s | 553.1 MB/s | **16.6 GB/s** | **517.7 GB/s** | 9669.2 GB/s | 331.2 MB/s | **10.7 GB/s** | **63.2 GB/s** | **41.7 GB/s** | 276.7 MB/s | 10.5 GB/s | 56.2 GB/s | 50.0 GB/s | 287.8 MB/s | **11.0 GB/s** | **55.9 GB/s** | **50.8 GB/s** |
| rust/regexold | **507.3 MB/s** | 2.4 GB/s | 534.5 MB/s | 1545.0 MB/s | 3.6 GB/s | 710.8 MB/s | 1305.0 MB/s | 19.1 GB/s | 590.4 MB/s | 8.6 GB/s | 284.4 MB/s | 360.3 MB/s | 349.2 MB/s | 344.4 MB/s | 50.6 GB/s | 483.5 MB/s | 2.2 GB/s | 25.7 GB/s | 70.2 GB/s | 41.8 GB/s | 972.7 MB/s | 19.4 GB/s | 623.2 GB/s | 19148.6 GB/s | **2.6 GB/s** | **46.6 GB/s** | **1454.4 GB/s** | **39063.5 GB/s** | 801.6 MB/s | 16.3 GB/s | 517.7 GB/s | **13754.7 GB/s** | 468.8 MB/s | 801.1 MB/s | 809.6 MB/s | 826.5 MB/s | 304.9 MB/s | **12.4 GB/s** | **57.7 GB/s** | **50.0 GB/s** | 463.2 MB/s | 802.2 MB/s | 825.9 MB/s | 826.5 MB/s |

<details>
<summary>Show individual benchmark parameters.</summary>

**no-exponential**

| Parameter | Value |
| --------- | ----- |
| full name | `imported/rsc/no-exponential` |
| model | [`count-spans`](MODELS.md#count-spans) |
| regex | `````(a+)*[b-z]````` |
| case-insensitive | `false` |
| unicode | `false` |
| haystack | `aaaaaaaaaaaaaaaaaaaaaaaaa` |
| count | 0 |


**literal**

| Parameter | Value |
| --------- | ----- |
| full name | `imported/rsc/literal` |
| model | [`count-spans`](MODELS.md#count-spans) |
| regex | `````y````` |
| case-insensitive | `false` |
| unicode | `false` |
| haystack | `xxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxy` |
| count | 1 |


**not-literal**

| Parameter | Value |
| --------- | ----- |
| full name | `imported/rsc/not-literal` |
| model | [`count-spans`](MODELS.md#count-spans) |
| regex | `````.y````` |
| case-insensitive | `false` |
| unicode | `false` |
| haystack | `xxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxy` |
| count | 2 |


**match-class**

| Parameter | Value |
| --------- | ----- |
| full name | `imported/rsc/match-class` |
| model | [`count-spans`](MODELS.md#count-spans) |
| regex | `````[abcdw]````` |
| case-insensitive | `false` |
| unicode | `false` |
| haystack | `xxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxx [.. snip ..]` |
| count | 1 |


**match-class-in-range**

| Parameter | Value |
| --------- | ----- |
| full name | `imported/rsc/match-class-in-range` |
| model | [`count-spans`](MODELS.md#count-spans) |
| regex | `````[ac]````` |
| case-insensitive | `false` |
| unicode | `false` |
| haystack | `bbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbb [.. snip ..]` |
| count | 1 |


**match-class-unicode**

| Parameter | Value |
| --------- | ----- |
| full name | `imported/rsc/match-class-unicode` |
| model | [`count-spans`](MODELS.md#count-spans) |
| regex | `````\pL````` |
| case-insensitive | `false` |
| unicode | `true` |
| haystack | `☃5☃5☃5☃5☃5☃5☃5☃5☃5☃5☃5☃5☃5☃5☃5 [.. snip ..]` |
| count | 1 |


**anchored-literal-short-non-match**

| Parameter | Value |
| --------- | ----- |
| full name | `imported/rsc/anchored-literal-short-non-match` |
| model | [`count-spans`](MODELS.md#count-spans) |
| regex | `````^zbc(d\|e)````` |
| case-insensitive | `false` |
| unicode | `false` |
| haystack | `abcdefghijklmnopqrstuvwxyz` |
| count | 0 |


**anchored-literal-long-non-match**

| Parameter | Value |
| --------- | ----- |
| full name | `imported/rsc/anchored-literal-long-non-match` |
| model | [`count-spans`](MODELS.md#count-spans) |
| regex | `````^zbc(d\|e)````` |
| case-insensitive | `false` |
| unicode | `false` |
| haystack-path | [`imported/rsc/anchored-literal-long.txt`](benchmarks/haystacks/imported/rsc/anchored-literal-long.txt) |
| count | 0 |


**anchored-literal-short-match**

| Parameter | Value |
| --------- | ----- |
| full name | `imported/rsc/anchored-literal-short-match` |
| model | [`count-spans`](MODELS.md#count-spans) |
| regex | `````^.bc(d\|e)````` |
| case-insensitive | `false` |
| unicode | `false` |
| haystack | `abcdefghijklmnopqrstuvwxyz` |
| count | 4 |


**anchored-literal-long-match**

| Parameter | Value |
| --------- | ----- |
| full name | `imported/rsc/anchored-literal-long-match` |
| model | [`count-spans`](MODELS.md#count-spans) |
| regex | `````^.bc(d\|e)````` |
| case-insensitive | `false` |
| unicode | `false` |
| haystack-path | [`imported/rsc/anchored-literal-long.txt`](benchmarks/haystacks/imported/rsc/anchored-literal-long.txt) |
| count | 4 |


**one-pass-short**

| Parameter | Value |
| --------- | ----- |
| full name | `imported/rsc/one-pass-short` |
| model | [`count-spans`](MODELS.md#count-spans) |
| regex | `````^.bc(d\|e)*$````` |
| case-insensitive | `false` |
| unicode | `false` |
| haystack | `abcddddddeeeededd` |
| count | 17 |


**one-pass-short-not**

| Parameter | Value |
| --------- | ----- |
| full name | `imported/rsc/one-pass-short-not` |
| model | [`count-spans`](MODELS.md#count-spans) |
| regex | `````.bc(d\|e)*$````` |
| case-insensitive | `false` |
| unicode | `false` |
| haystack | `abcddddddeeeededd` |
| count | 17 |


**one-pass-long-prefix**

| Parameter | Value |
| --------- | ----- |
| full name | `imported/rsc/one-pass-long-prefix` |
| model | [`count-spans`](MODELS.md#count-spans) |
| regex | `````^abcdefghijklmnopqrstuvwxyz.*$````` |
| case-insensitive | `false` |
| unicode | `false` |
| haystack | `abcdefghijklmnopqrstuvwxyz` |
| count | 26 |


**one-pass-long-prefix-not**

| Parameter | Value |
| --------- | ----- |
| full name | `imported/rsc/one-pass-long-prefix-not` |
| model | [`count-spans`](MODELS.md#count-spans) |
| regex | `````^.bcdefghijklmnopqrstuvwxyz.*$````` |
| case-insensitive | `false` |
| unicode | `false` |
| haystack | `abcdefghijklmnopqrstuvwxyz` |
| count | 26 |


**long-needle1**

| Parameter | Value |
| --------- | ----- |
| full name | `imported/rsc/long-needle1` |
| model | [`count-spans`](MODELS.md#count-spans) |
| regex | `````aaaaaaaaaaaaaaaaaaaaaaaaaaaaaab````` |
| case-insensitive | `false` |
| unicode | `false` |
| haystack-path | [`imported/rsc/long-needle1.txt`](benchmarks/haystacks/imported/rsc/long-needle1.txt) |
| count | 31 |


**long-needle2**

| Parameter | Value |
| --------- | ----- |
| full name | `imported/rsc/long-needle2` |
| model | [`count-spans`](MODELS.md#count-spans) |
| regex | `````bbbbbbbbbbbbbbbbbbbbbbbbbbbbbba````` |
| case-insensitive | `false` |
| unicode | `false` |
| haystack-path | [`imported/rsc/long-needle2.txt`](benchmarks/haystacks/imported/rsc/long-needle2.txt) |
| count | 31 |


**easy0-32**

| Parameter | Value |
| --------- | ----- |
| full name | `imported/rsc/easy0-32` |
| model | [`count-spans`](MODELS.md#count-spans) |
| regex | `````ABCDEFGHIJKLMNOPQRSTUVWXYZ````` |
| case-insensitive | `false` |
| unicode | `false` |
| haystack-path | [`imported/rsc/32.txt`](benchmarks/haystacks/imported/rsc/32.txt) |
| count | 26 |


**easy0-1k**

| Parameter | Value |
| --------- | ----- |
| full name | `imported/rsc/easy0-1k` |
| model | [`count-spans`](MODELS.md#count-spans) |
| regex | `````ABCDEFGHIJKLMNOPQRSTUVWXYZ````` |
| case-insensitive | `false` |
| unicode | `false` |
| haystack-path | [`imported/rsc/1K.txt`](benchmarks/haystacks/imported/rsc/1K.txt) |
| count | 26 |


**easy0-32k**

| Parameter | Value |
| --------- | ----- |
| full name | `imported/rsc/easy0-32k` |
| model | [`count-spans`](MODELS.md#count-spans) |
| regex | `````ABCDEFGHIJKLMNOPQRSTUVWXYZ````` |
| case-insensitive | `false` |
| unicode | `false` |
| haystack-path | [`imported/rsc/32K.txt`](benchmarks/haystacks/imported/rsc/32K.txt) |
| count | 26 |


**easy0-1mb**

| Parameter | Value |
| --------- | ----- |
| full name | `imported/rsc/easy0-1mb` |
| model | [`count-spans`](MODELS.md#count-spans) |
| regex | `````ABCDEFGHIJKLMNOPQRSTUVWXYZ````` |
| case-insensitive | `false` |
| unicode | `false` |
| haystack-path | [`imported/rsc/1MB.txt`](benchmarks/haystacks/imported/rsc/1MB.txt) |
| count | 26 |


**easy1-32**

| Parameter | Value |
| --------- | ----- |
| full name | `imported/rsc/easy1-32` |
| model | [`count-spans`](MODELS.md#count-spans) |
| regex | `````A[AB]B[BC]C[CD]D[DE]E[EF]F[FG]G[GH]H[HI]I[IJ]J$````` |
| case-insensitive | `false` |
| unicode | `false` |
| haystack-path | [`imported/rsc/32.txt`](benchmarks/haystacks/imported/rsc/32.txt) |
| count | 19 |


**easy1-1k**

| Parameter | Value |
| --------- | ----- |
| full name | `imported/rsc/easy1-1k` |
| model | [`count-spans`](MODELS.md#count-spans) |
| regex | `````A[AB]B[BC]C[CD]D[DE]E[EF]F[FG]G[GH]H[HI]I[IJ]J$````` |
| case-insensitive | `false` |
| unicode | `false` |
| haystack-path | [`imported/rsc/1K.txt`](benchmarks/haystacks/imported/rsc/1K.txt) |
| count | 19 |


**easy1-32k**

| Parameter | Value |
| --------- | ----- |
| full name | `imported/rsc/easy1-32k` |
| model | [`count-spans`](MODELS.md#count-spans) |
| regex | `````A[AB]B[BC]C[CD]D[DE]E[EF]F[FG]G[GH]H[HI]I[IJ]J$````` |
| case-insensitive | `false` |
| unicode | `false` |
| haystack-path | [`imported/rsc/32K.txt`](benchmarks/haystacks/imported/rsc/32K.txt) |
| count | 19 |


**easy1-1mb**

| Parameter | Value |
| --------- | ----- |
| full name | `imported/rsc/easy1-1mb` |
| model | [`count-spans`](MODELS.md#count-spans) |
| regex | `````A[AB]B[BC]C[CD]D[DE]E[EF]F[FG]G[GH]H[HI]I[IJ]J$````` |
| case-insensitive | `false` |
| unicode | `false` |
| haystack-path | [`imported/rsc/1MB.txt`](benchmarks/haystacks/imported/rsc/1MB.txt) |
| count | 19 |


**medium-32**

| Parameter | Value |
| --------- | ----- |
| full name | `imported/rsc/medium-32` |
| model | [`count-spans`](MODELS.md#count-spans) |
| regex | `````[XYZ]ABCDEFGHIJKLMNOPQRSTUVWXYZ$````` |
| case-insensitive | `false` |
| unicode | `false` |
| haystack-path | [`imported/rsc/32.txt`](benchmarks/haystacks/imported/rsc/32.txt) |
| count | 27 |


**medium-1k**

| Parameter | Value |
| --------- | ----- |
| full name | `imported/rsc/medium-1k` |
| model | [`count-spans`](MODELS.md#count-spans) |
| regex | `````[XYZ]ABCDEFGHIJKLMNOPQRSTUVWXYZ$````` |
| case-insensitive | `false` |
| unicode | `false` |
| haystack-path | [`imported/rsc/1K.txt`](benchmarks/haystacks/imported/rsc/1K.txt) |
| count | 27 |


**medium-32k**

| Parameter | Value |
| --------- | ----- |
| full name | `imported/rsc/medium-32k` |
| model | [`count-spans`](MODELS.md#count-spans) |
| regex | `````[XYZ]ABCDEFGHIJKLMNOPQRSTUVWXYZ$````` |
| case-insensitive | `false` |
| unicode | `false` |
| haystack-path | [`imported/rsc/32K.txt`](benchmarks/haystacks/imported/rsc/32K.txt) |
| count | 27 |


**medium-1mb**

| Parameter | Value |
| --------- | ----- |
| full name | `imported/rsc/medium-1mb` |
| model | [`count-spans`](MODELS.md#count-spans) |
| regex | `````[XYZ]ABCDEFGHIJKLMNOPQRSTUVWXYZ$````` |
| case-insensitive | `false` |
| unicode | `false` |
| haystack-path | [`imported/rsc/1MB.txt`](benchmarks/haystacks/imported/rsc/1MB.txt) |
| count | 27 |


**hard-32**

| Parameter | Value |
| --------- | ----- |
| full name | `imported/rsc/hard-32` |
| model | [`count-spans`](MODELS.md#count-spans) |
| regex | `````[ -~]*ABCDEFGHIJKLMNOPQRSTUVWXYZ$````` |
| case-insensitive | `false` |
| unicode | `false` |
| haystack-path | [`imported/rsc/32.txt`](benchmarks/haystacks/imported/rsc/32.txt) |
| count | 58 |


**hard-1k**

| Parameter | Value |
| --------- | ----- |
| full name | `imported/rsc/hard-1k` |
| model | [`count-spans`](MODELS.md#count-spans) |
| regex | `````[ -~]*ABCDEFGHIJKLMNOPQRSTUVWXYZ$````` |
| case-insensitive | `false` |
| unicode | `false` |
| haystack-path | [`imported/rsc/1K.txt`](benchmarks/haystacks/imported/rsc/1K.txt) |
| count | 27 |


**hard-32k**

| Parameter | Value |
| --------- | ----- |
| full name | `imported/rsc/hard-32k` |
| model | [`count-spans`](MODELS.md#count-spans) |
| regex | `````[ -~]*ABCDEFGHIJKLMNOPQRSTUVWXYZ$````` |
| case-insensitive | `false` |
| unicode | `false` |
| haystack-path | [`imported/rsc/32K.txt`](benchmarks/haystacks/imported/rsc/32K.txt) |
| count | 27 |


**hard-1mb**

| Parameter | Value |
| --------- | ----- |
| full name | `imported/rsc/hard-1mb` |
| model | [`count-spans`](MODELS.md#count-spans) |
| regex | `````[ -~]*ABCDEFGHIJKLMNOPQRSTUVWXYZ$````` |
| case-insensitive | `false` |
| unicode | `false` |
| haystack-path | [`imported/rsc/1MB.txt`](benchmarks/haystacks/imported/rsc/1MB.txt) |
| count | 51 |


**reallyhard0-32**

| Parameter | Value |
| --------- | ----- |
| full name | `imported/rsc/reallyhard0-32` |
| model | [`count-spans`](MODELS.md#count-spans) |
| regex | `````[ -~]*ABCDEFGHIJKLMNOPQRSTUVWXYZ.*````` |
| case-insensitive | `false` |
| unicode | `false` |
| haystack-path | [`imported/rsc/32.txt`](benchmarks/haystacks/imported/rsc/32.txt) |
| count | 58 |


**reallyhard0-1k**

| Parameter | Value |
| --------- | ----- |
| full name | `imported/rsc/reallyhard0-1k` |
| model | [`count-spans`](MODELS.md#count-spans) |
| regex | `````[ -~]*ABCDEFGHIJKLMNOPQRSTUVWXYZ.*````` |
| case-insensitive | `false` |
| unicode | `false` |
| haystack-path | [`imported/rsc/1K.txt`](benchmarks/haystacks/imported/rsc/1K.txt) |
| count | 27 |


**reallyhard0-32k**

| Parameter | Value |
| --------- | ----- |
| full name | `imported/rsc/reallyhard0-32k` |
| model | [`count-spans`](MODELS.md#count-spans) |
| regex | `````[ -~]*ABCDEFGHIJKLMNOPQRSTUVWXYZ.*````` |
| case-insensitive | `false` |
| unicode | `false` |
| haystack-path | [`imported/rsc/32K.txt`](benchmarks/haystacks/imported/rsc/32K.txt) |
| count | 27 |


**reallyhard0-1mb**

| Parameter | Value |
| --------- | ----- |
| full name | `imported/rsc/reallyhard0-1mb` |
| model | [`count-spans`](MODELS.md#count-spans) |
| regex | `````[ -~]*ABCDEFGHIJKLMNOPQRSTUVWXYZ.*````` |
| case-insensitive | `false` |
| unicode | `false` |
| haystack-path | [`imported/rsc/1MB.txt`](benchmarks/haystacks/imported/rsc/1MB.txt) |
| count | 51 |


**reallyreallyhard0-32**

| Parameter | Value |
| --------- | ----- |
| full name | `imported/rsc/reallyreallyhard0-32` |
| model | [`count-spans`](MODELS.md#count-spans) |
| regex | `````\w+\s+Holmes````` |
| case-insensitive | `false` |
| unicode | `false` |
| haystack-path | [`imported/rsc/32.txt`](benchmarks/haystacks/imported/rsc/32.txt) |
| count | 47 |


**reallyreallyhard0-1k**

| Parameter | Value |
| --------- | ----- |
| full name | `imported/rsc/reallyreallyhard0-1k` |
| model | [`count-spans`](MODELS.md#count-spans) |
| regex | `````\w+\s+Holmes````` |
| case-insensitive | `false` |
| unicode | `false` |
| haystack-path | [`imported/rsc/1K.txt`](benchmarks/haystacks/imported/rsc/1K.txt) |
| count | 16 |


**reallyreallyhard0-32k**

| Parameter | Value |
| --------- | ----- |
| full name | `imported/rsc/reallyreallyhard0-32k` |
| model | [`count-spans`](MODELS.md#count-spans) |
| regex | `````\w+\s+Holmes````` |
| case-insensitive | `false` |
| unicode | `false` |
| haystack-path | [`imported/rsc/32K.txt`](benchmarks/haystacks/imported/rsc/32K.txt) |
| count | 16 |


**reallyreallyhard0-1mb**

| Parameter | Value |
| --------- | ----- |
| full name | `imported/rsc/reallyreallyhard0-1mb` |
| model | [`count-spans`](MODELS.md#count-spans) |
| regex | `````\w+\s+Holmes````` |
| case-insensitive | `false` |
| unicode | `false` |
| haystack-path | [`imported/rsc/1MB.txt`](benchmarks/haystacks/imported/rsc/1MB.txt) |
| count | 40 |


**reallyreallyreallyhard0-32**

| Parameter | Value |
| --------- | ----- |
| full name | `imported/rsc/reallyreallyreallyhard0-32` |
| model | [`count-spans`](MODELS.md#count-spans) |
| regex | `````\w+\s+Holmes\s+\w+````` |
| case-insensitive | `false` |
| unicode | `false` |
| haystack-path | [`imported/rsc/32.txt`](benchmarks/haystacks/imported/rsc/32.txt) |
| count | 51 |


**reallyreallyreallyhard0-1k**

| Parameter | Value |
| --------- | ----- |
| full name | `imported/rsc/reallyreallyreallyhard0-1k` |
| model | [`count-spans`](MODELS.md#count-spans) |
| regex | `````\w+\s+Holmes\s+\w+````` |
| case-insensitive | `false` |
| unicode | `false` |
| haystack-path | [`imported/rsc/1K.txt`](benchmarks/haystacks/imported/rsc/1K.txt) |
| count | 20 |


**reallyreallyreallyhard0-32k**

| Parameter | Value |
| --------- | ----- |
| full name | `imported/rsc/reallyreallyreallyhard0-32k` |
| model | [`count-spans`](MODELS.md#count-spans) |
| regex | `````\w+\s+Holmes\s+\w+````` |
| case-insensitive | `false` |
| unicode | `false` |
| haystack-path | [`imported/rsc/32K.txt`](benchmarks/haystacks/imported/rsc/32K.txt) |
| count | 20 |


**reallyreallyreallyhard0-1mb**

| Parameter | Value |
| --------- | ----- |
| full name | `imported/rsc/reallyreallyreallyhard0-1mb` |
| model | [`count-spans`](MODELS.md#count-spans) |
| regex | `````\w+\s+Holmes\s+\w+````` |
| case-insensitive | `false` |
| unicode | `false` |
| haystack-path | [`imported/rsc/1MB.txt`](benchmarks/haystacks/imported/rsc/1MB.txt) |
| count | 44 |


</details>

#### sherlock

| Engine | name-sherlock | name-holmes | name-sherlock-holmes | name-sherlock-casei | name-holmes-casei | name-sherlock-holmes-casei | name-whitespace | name-alt1 | name-alt2 | name-alt3 | name-alt3-casei | name-alt4 | name-alt4-casei | name-alt5 | name-alt5-casei | no-match-uncommon | no-match-common | no-match-really-common | the-lower | the-upper | the-casei | everything-greedy | everything-greedy-nl | letters | letters-upper | letters-lower | words | before-holmes | before-after-holmes | holmes-cochar-watson | holmes-coword-watson | quotes | line-boundary-sherlock-holmes | word-ending-n | repeated-class-negation | ing-suffix | ing-suffix-limited-space |
| - | - | - | - | - | - | - | - | - | - | - | - | - | - | - | - | - | - | - | - | - | - | - | - | - | - | - | - | - | - | - | - | - | - | - | - | - | - |
| go/regexp | 14.2 GB/s | 5.4 GB/s | 12.0 GB/s | 43.4 MB/s | 64.7 MB/s | 43.5 MB/s | 10.7 GB/s | 6.1 GB/s | 48.2 MB/s | 14.5 MB/s | 8.9 MB/s | 48.2 MB/s | 27.0 MB/s | 32.5 MB/s | 19.8 MB/s | 59.5 GB/s | 2.3 GB/s | 2.5 GB/s | 291.0 MB/s | 4.3 GB/s | 56.2 MB/s | 38.4 MB/s | 46.4 MB/s | 7.4 MB/s | 37.5 MB/s | 8.5 MB/s | 19.9 MB/s | 34.3 MB/s | 34.1 MB/s | 46.9 MB/s | 9.4 MB/s | 50.5 MB/s | 54.5 MB/s | 32.0 MB/s | 15.6 MB/s | 40.5 MB/s | 29.3 MB/s |
| pcre2 | 19.5 GB/s | 11.0 GB/s | 22.9 GB/s | 828.1 MB/s | 733.2 MB/s | 969.5 MB/s | 22.6 GB/s | 16.8 GB/s | 1876.4 MB/s | 828.2 MB/s | 58.4 MB/s | 1867.3 MB/s | 274.1 MB/s | 1642.3 MB/s | 199.1 MB/s | 75.6 GB/s | 1026.6 MB/s | 866.4 MB/s | 540.4 MB/s | 12.3 GB/s | 439.8 MB/s | - | **4.8 GB/s** | - | 714.4 KB/s | - | 116.5 MB/s | 44.4 MB/s | 44.3 MB/s | 1515.0 MB/s | - | 476.8 MB/s | 37.4 MB/s | 55.4 MB/s | 63.3 MB/s | 33.7 MB/s | 79.2 MB/s |
| pcre2/jit | 36.0 GB/s | 25.5 GB/s | 36.4 GB/s | **14.9 GB/s** | **13.2 GB/s** | **22.5 GB/s** | 34.1 GB/s | 27.0 GB/s | 17.0 GB/s | 1350.6 MB/s | 348.1 MB/s | 16.5 GB/s | 850.2 MB/s | 1250.5 MB/s | 704.7 MB/s | 46.3 GB/s | **46.2 GB/s** | 45.9 GB/s | 2.4 GB/s | 20.5 GB/s | **2.1 GB/s** | **1005.6 MB/s** | 4.8 GB/s | **83.1 MB/s** | **556.2 MB/s** | **83.6 MB/s** | **234.5 MB/s** | 370.8 MB/s | 375.7 MB/s | **17.6 GB/s** | - | **2.7 GB/s** | **33.4 GB/s** | 313.5 MB/s | 193.6 MB/s | 402.4 MB/s | 322.4 MB/s |
| python/re | 4.3 GB/s | 3.5 GB/s | 4.3 GB/s | 292.5 MB/s | 282.3 MB/s | 292.5 MB/s | 4.1 GB/s | 3.5 GB/s | 408.2 MB/s | 420.3 MB/s | 25.9 MB/s | 417.2 MB/s | 87.3 MB/s | 472.8 MB/s | 65.2 MB/s | 4.8 GB/s | 1278.4 MB/s | 1279.5 MB/s | 540.4 MB/s | 3.1 GB/s | 180.1 MB/s | 132.9 MB/s | 2.9 GB/s | - | - | - | 36.4 MB/s | 32.1 MB/s | 31.9 MB/s | 465.1 MB/s | - | 266.4 MB/s | 143.6 MB/s | 79.1 MB/s | 50.3 MB/s | 66.1 MB/s | 101.9 MB/s |
| python/regex | 2.5 GB/s | 1789.5 MB/s | 4.1 GB/s | 2.7 GB/s | 1611.3 MB/s | 3.3 GB/s | 2.6 GB/s | 3.5 GB/s | 394.0 MB/s | 262.7 MB/s | 45.9 MB/s | 394.0 MB/s | 101.1 MB/s | 383.4 MB/s | 86.2 MB/s | 4.8 GB/s | 1476.8 MB/s | 1499.7 MB/s | 436.4 MB/s | 2.7 GB/s | 274.1 MB/s | 133.2 MB/s | 3.0 GB/s | 10.0 MB/s | 188.5 MB/s | 10.2 MB/s | 31.6 MB/s | 18.4 MB/s | 18.1 MB/s | 402.4 MB/s | - | 218.2 MB/s | 2.7 GB/s | 38.5 MB/s | 2.4 GB/s | 23.4 MB/s | 443.3 MB/s |
| re2 | 35.7 GB/s | 12.7 GB/s | 30.9 GB/s | 2.8 GB/s | 2.5 GB/s | 2.8 GB/s | 31.1 GB/s | 27.9 GB/s | 924.5 MB/s | 903.3 MB/s | 901.9 MB/s | 923.5 MB/s | 910.5 MB/s | 915.8 MB/s | 914.3 MB/s | **105.3 GB/s** | 3.3 GB/s | 3.1 GB/s | 776.7 MB/s | 8.7 GB/s | 691.2 MB/s | 210.9 MB/s | 493.4 MB/s | 21.1 MB/s | 370.8 MB/s | 21.6 MB/s | 69.0 MB/s | 945.5 MB/s | 967.1 MB/s | 987.4 MB/s | 889.4 MB/s | 880.7 MB/s | 983.8 MB/s | 461.3 MB/s | 310.0 MB/s | 709.5 MB/s | 759.6 MB/s |
| regress | 3.6 GB/s | 3.5 GB/s | 3.6 GB/s | 1134.7 MB/s | 2.4 GB/s | 1153.6 MB/s | 3.6 GB/s | **56.2 GB/s** | **22.1 GB/s** | 1582.2 MB/s | 124.2 MB/s | **18.5 GB/s** | 502.1 MB/s | 2.6 GB/s | 356.8 MB/s | 2.4 GB/s | 2.4 GB/s | 2.4 GB/s | 1750.2 MB/s | 2.3 GB/s | 1340.3 MB/s | 709.6 MB/s | - | - | - | - | 220.8 MB/s | 41.5 MB/s | 41.2 MB/s | 9.5 GB/s | - | - | - | - | 68.9 MB/s | 88.8 MB/s | 164.9 MB/s |
| rust/memchr/memmem | **39.8 GB/s** | **32.6 GB/s** | 37.9 GB/s | - | - | - | - | - | - | - | - | - | - | - | - | - | - | - | **3.9 GB/s** | **31.6 GB/s** | - | - | - | - | - | - | - | - | - | - | - | - | - | - | - | - | - |
| rust/regex/meta | 37.4 GB/s | 30.9 GB/s | 32.9 GB/s | 14.3 GB/s | 7.2 GB/s | 13.9 GB/s | 26.3 GB/s | 41.3 GB/s | 12.6 GB/s | 11.5 GB/s | **1861.1 MB/s** | 10.3 GB/s | 5.4 GB/s | 10.0 GB/s | **3.4 GB/s** | 34.1 GB/s | 40.6 GB/s | **55.1 GB/s** | 3.3 GB/s | 27.9 GB/s | 1836.3 MB/s | 197.7 MB/s | 241.4 MB/s | 44.5 MB/s | 476.8 MB/s | 45.1 MB/s | 101.9 MB/s | 17.6 GB/s | **16.8 GB/s** | 9.0 GB/s | 1692.0 MB/s | 2.5 GB/s | 32.2 GB/s | **886.1 MB/s** | **20.9 GB/s** | 3.5 GB/s | **3.3 GB/s** |
| rust/regexold | 37.4 GB/s | 31.8 GB/s | **38.6 GB/s** | 11.4 GB/s | 9.7 GB/s | 10.3 GB/s | **36.4 GB/s** | 51.0 GB/s | 17.2 GB/s | **16.1 GB/s** | 1814.9 MB/s | 11.5 GB/s | **6.4 GB/s** | **13.0 GB/s** | 1374.5 MB/s | 40.6 GB/s | 40.6 GB/s | 53.1 GB/s | 3.2 GB/s | 26.5 GB/s | 2.1 GB/s | 545.6 MB/s | 1282.1 MB/s | 59.5 MB/s | 520.5 MB/s | 60.4 MB/s | 127.2 MB/s | **19.0 GB/s** | 818.1 MB/s | 13.0 GB/s | **1730.9 MB/s** | 2.4 GB/s | 824.8 MB/s | 556.2 MB/s | 468.9 MB/s | **3.7 GB/s** | 579.0 MB/s |

<details>
<summary>Show individual benchmark parameters.</summary>

**name-sherlock**

| Parameter | Value |
| --------- | ----- |
| full name | `imported/sherlock/name-sherlock` |
| model | [`count-spans`](MODELS.md#count-spans) |
| regex | `````Sherlock````` |
| case-insensitive | `false` |
| unicode | `false` |
| haystack-path | [`sherlock.txt`](benchmarks/haystacks/sherlock.txt) |
| count | 776 |


**name-holmes**

| Parameter | Value |
| --------- | ----- |
| full name | `imported/sherlock/name-holmes` |
| model | [`count-spans`](MODELS.md#count-spans) |
| regex | `````Holmes````` |
| case-insensitive | `false` |
| unicode | `false` |
| haystack-path | [`sherlock.txt`](benchmarks/haystacks/sherlock.txt) |
| count | 2766 |


**name-sherlock-holmes**

| Parameter | Value |
| --------- | ----- |
| full name | `imported/sherlock/name-sherlock-holmes` |
| model | [`count-spans`](MODELS.md#count-spans) |
| regex | `````Sherlock Holmes````` |
| case-insensitive | `false` |
| unicode | `false` |
| haystack-path | [`sherlock.txt`](benchmarks/haystacks/sherlock.txt) |
| count | 1365 |


**name-sherlock-casei**

| Parameter | Value |
| --------- | ----- |
| full name | `imported/sherlock/name-sherlock-casei` |
| model | [`count-spans`](MODELS.md#count-spans) |
| regex | `````Sherlock````` |
| case-insensitive | `true` |
| unicode | `false` |
| haystack-path | [`sherlock.txt`](benchmarks/haystacks/sherlock.txt) |
| count | 816 |


**name-holmes-casei**

| Parameter | Value |
| --------- | ----- |
| full name | `imported/sherlock/name-holmes-casei` |
| model | [`count-spans`](MODELS.md#count-spans) |
| regex | `````Holmes````` |
| case-insensitive | `true` |
| unicode | `false` |
| haystack-path | [`sherlock.txt`](benchmarks/haystacks/sherlock.txt) |
| count | 2802 |


**name-sherlock-holmes-casei**

| Parameter | Value |
| --------- | ----- |
| full name | `imported/sherlock/name-sherlock-holmes-casei` |
| model | [`count-spans`](MODELS.md#count-spans) |
| regex | `````Sherlock Holmes````` |
| case-insensitive | `true` |
| unicode | `false` |
| haystack-path | [`sherlock.txt`](benchmarks/haystacks/sherlock.txt) |
| count | 1440 |


**name-whitespace**

| Parameter | Value |
| --------- | ----- |
| full name | `imported/sherlock/name-whitespace` |
| model | [`count-spans`](MODELS.md#count-spans) |
| regex | `````Sherlock\s+Holmes````` |
| case-insensitive | `false` |
| unicode | `false` |
| haystack-path | [`sherlock.txt`](benchmarks/haystacks/sherlock.txt) |
| count | 1461 |


**name-alt1**

| Parameter | Value |
| --------- | ----- |
| full name | `imported/sherlock/name-alt1` |
| model | [`count-spans`](MODELS.md#count-spans) |
| regex | `````Sherlock\|Street````` |
| case-insensitive | `false` |
| unicode | `false` |
| haystack-path | [`sherlock.txt`](benchmarks/haystacks/sherlock.txt) |
| count | 1142 |


**name-alt2**

| Parameter | Value |
| --------- | ----- |
| full name | `imported/sherlock/name-alt2` |
| model | [`count-spans`](MODELS.md#count-spans) |
| regex | `````Sherlock\|Holmes````` |
| case-insensitive | `false` |
| unicode | `false` |
| haystack-path | [`sherlock.txt`](benchmarks/haystacks/sherlock.txt) |
| count | 3542 |


**name-alt3**

| Parameter | Value |
| --------- | ----- |
| full name | `imported/sherlock/name-alt3` |
| model | [`count-spans`](MODELS.md#count-spans) |
| regex | `````Sherlock\|Holmes\|Watson\|Irene\|Adler\|John\|Baker````` |
| case-insensitive | `false` |
| unicode | `false` |
| haystack-path | [`sherlock.txt`](benchmarks/haystacks/sherlock.txt) |
| count | 4507 |


**name-alt3-casei**

| Parameter | Value |
| --------- | ----- |
| full name | `imported/sherlock/name-alt3-casei` |
| model | [`count-spans`](MODELS.md#count-spans) |
| regex | `````Sherlock\|Holmes\|Watson\|Irene\|Adler\|John\|Baker````` |
| case-insensitive | `true` |
| unicode | `false` |
| haystack-path | [`sherlock.txt`](benchmarks/haystacks/sherlock.txt) |
| count | 4593 |


**name-alt4**

| Parameter | Value |
| --------- | ----- |
| full name | `imported/sherlock/name-alt4` |
| model | [`count-spans`](MODELS.md#count-spans) |
| regex | `````Sher[a-z]+\|Hol[a-z]+````` |
| case-insensitive | `false` |
| unicode | `false` |
| haystack-path | [`sherlock.txt`](benchmarks/haystacks/sherlock.txt) |
| count | 3686 |


**name-alt4-casei**

| Parameter | Value |
| --------- | ----- |
| full name | `imported/sherlock/name-alt4-casei` |
| model | [`count-spans`](MODELS.md#count-spans) |
| regex | `````Sher[a-z]+\|Hol[a-z]+````` |
| case-insensitive | `true` |
| unicode | `false` |
| haystack-path | [`sherlock.txt`](benchmarks/haystacks/sherlock.txt) |
| count | 4254 |


**name-alt5**

| Parameter | Value |
| --------- | ----- |
| full name | `imported/sherlock/name-alt5` |
| model | [`count-spans`](MODELS.md#count-spans) |
| regex | `````Sherlock\|Holmes\|Watson````` |
| case-insensitive | `false` |
| unicode | `false` |
| haystack-path | [`sherlock.txt`](benchmarks/haystacks/sherlock.txt) |
| count | 4028 |


**name-alt5-casei**

| Parameter | Value |
| --------- | ----- |
| full name | `imported/sherlock/name-alt5-casei` |
| model | [`count-spans`](MODELS.md#count-spans) |
| regex | `````Sherlock\|Holmes\|Watson````` |
| case-insensitive | `true` |
| unicode | `false` |
| haystack-path | [`sherlock.txt`](benchmarks/haystacks/sherlock.txt) |
| count | 4104 |


**no-match-uncommon**

| Parameter | Value |
| --------- | ----- |
| full name | `imported/sherlock/no-match-uncommon` |
| model | [`count-spans`](MODELS.md#count-spans) |
| regex | `````zqj````` |
| case-insensitive | `false` |
| unicode | `false` |
| haystack-path | [`sherlock.txt`](benchmarks/haystacks/sherlock.txt) |
| count | 0 |


**no-match-common**

| Parameter | Value |
| --------- | ----- |
| full name | `imported/sherlock/no-match-common` |
| model | [`count-spans`](MODELS.md#count-spans) |
| regex | `````aqj````` |
| case-insensitive | `false` |
| unicode | `false` |
| haystack-path | [`sherlock.txt`](benchmarks/haystacks/sherlock.txt) |
| count | 0 |


**no-match-really-common**

| Parameter | Value |
| --------- | ----- |
| full name | `imported/sherlock/no-match-really-common` |
| model | [`count-spans`](MODELS.md#count-spans) |
| regex | `````aei````` |
| case-insensitive | `false` |
| unicode | `false` |
| haystack-path | [`sherlock.txt`](benchmarks/haystacks/sherlock.txt) |
| count | 0 |


**the-lower**

| Parameter | Value |
| --------- | ----- |
| full name | `imported/sherlock/the-lower` |
| model | [`count-spans`](MODELS.md#count-spans) |
| regex | `````the````` |
| case-insensitive | `false` |
| unicode | `false` |
| haystack-path | [`sherlock.txt`](benchmarks/haystacks/sherlock.txt) |
| count | 21654 |


**the-upper**

| Parameter | Value |
| --------- | ----- |
| full name | `imported/sherlock/the-upper` |
| model | [`count-spans`](MODELS.md#count-spans) |
| regex | `````The````` |
| case-insensitive | `false` |
| unicode | `false` |
| haystack-path | [`sherlock.txt`](benchmarks/haystacks/sherlock.txt) |
| count | 2223 |


**the-casei**

| Parameter | Value |
| --------- | ----- |
| full name | `imported/sherlock/the-casei` |
| model | [`count-spans`](MODELS.md#count-spans) |
| regex | `````the````` |
| case-insensitive | `true` |
| unicode | `false` |
| haystack-path | [`sherlock.txt`](benchmarks/haystacks/sherlock.txt) |
| count | 23961 |


**everything-greedy**

| Parameter | Value |
| --------- | ----- |
| full name | `imported/sherlock/everything-greedy` |
| model | [`count-spans`](MODELS.md#count-spans) |
| regex | `````.*````` |
| case-insensitive | `false` |
| unicode | `true` |
| haystack-path | [`sherlock.txt`](benchmarks/haystacks/sherlock.txt) |
| count(\*) | 581881 |
| count(regress) | 568829 |


**everything-greedy-nl**

| Parameter | Value |
| --------- | ----- |
| full name | `imported/sherlock/everything-greedy-nl` |
| model | [`count-spans`](MODELS.md#count-spans) |
| regex | `````(?s).*````` |
| case-insensitive | `false` |
| unicode | `true` |
| haystack-path | [`sherlock.txt`](benchmarks/haystacks/sherlock.txt) |
| count | 594933 |


**letters**

| Parameter | Value |
| --------- | ----- |
| full name | `imported/sherlock/letters` |
| model | [`count-spans`](MODELS.md#count-spans) |
| regex | `````\pL````` |
| case-insensitive | `false` |
| unicode | `true` |
| haystack-path | [`sherlock.txt`](benchmarks/haystacks/sherlock.txt) |
| count | 447175 |


**letters-upper**

| Parameter | Value |
| --------- | ----- |
| full name | `imported/sherlock/letters-upper` |
| model | [`count-spans`](MODELS.md#count-spans) |
| regex | `````\p{Lu}````` |
| case-insensitive | `false` |
| unicode | `true` |
| haystack-path | [`sherlock.txt`](benchmarks/haystacks/sherlock.txt) |
| count | 14180 |


**letters-lower**

| Parameter | Value |
| --------- | ----- |
| full name | `imported/sherlock/letters-lower` |
| model | [`count-spans`](MODELS.md#count-spans) |
| regex | `````\p{Ll}````` |
| case-insensitive | `false` |
| unicode | `true` |
| haystack-path | [`sherlock.txt`](benchmarks/haystacks/sherlock.txt) |
| count | 432995 |


**words**

| Parameter | Value |
| --------- | ----- |
| full name | `imported/sherlock/words` |
| model | [`count-spans`](MODELS.md#count-spans) |
| regex | `````\w+````` |
| case-insensitive | `false` |
| unicode | `false` |
| haystack-path | [`sherlock.txt`](benchmarks/haystacks/sherlock.txt) |
| count | 447639 |


**before-holmes**

| Parameter | Value |
| --------- | ----- |
| full name | `imported/sherlock/before-holmes` |
| model | [`count-spans`](MODELS.md#count-spans) |
| regex | `````\w+\s+Holmes````` |
| case-insensitive | `false` |
| unicode | `false` |
| haystack-path | [`sherlock.txt`](benchmarks/haystacks/sherlock.txt) |
| count | 4073 |


**before-after-holmes**

| Parameter | Value |
| --------- | ----- |
| full name | `imported/sherlock/before-after-holmes` |
| model | [`count-spans`](MODELS.md#count-spans) |
| regex | `````\w+\s+Holmes\s+\w+````` |
| case-insensitive | `false` |
| unicode | `false` |
| haystack-path | [`sherlock.txt`](benchmarks/haystacks/sherlock.txt) |
| count | 2593 |


**holmes-cochar-watson**

| Parameter | Value |
| --------- | ----- |
| full name | `imported/sherlock/holmes-cochar-watson` |
| model | [`count-spans`](MODELS.md#count-spans) |
| regex | `````Holmes.{0,25}Watson\|Watson.{0,25}Holmes````` |
| case-insensitive | `false` |
| unicode | `false` |
| haystack-path | [`sherlock.txt`](benchmarks/haystacks/sherlock.txt) |
| count | 150 |


**holmes-coword-watson**

| Parameter | Value |
| --------- | ----- |
| full name | `imported/sherlock/holmes-coword-watson` |
| model | [`count-spans`](MODELS.md#count-spans) |
| regex | `````Holmes(?:\s*.+\s*){0,10}Watson\|Watson(?:\s*.+\s*){0,10}Holmes````` |
| case-insensitive | `false` |
| unicode | `false` |
| haystack-path | [`sherlock.txt`](benchmarks/haystacks/sherlock.txt) |
| count | 14309 |


**quotes**

| Parameter | Value |
| --------- | ----- |
| full name | `imported/sherlock/quotes` |
| model | [`count-spans`](MODELS.md#count-spans) |
| regex | `````["'][^"']{0,30}[?!.]["']````` |
| case-insensitive | `false` |
| unicode | `false` |
| haystack-path | [`sherlock.txt`](benchmarks/haystacks/sherlock.txt) |
| count | 14437 |


**line-boundary-sherlock-holmes**

| Parameter | Value |
| --------- | ----- |
| full name | `imported/sherlock/line-boundary-sherlock-holmes` |
| model | [`count-spans`](MODELS.md#count-spans) |
| regex | `````(?m)^Sherlock Holmes\|Sherlock Holmes$````` |
| case-insensitive | `false` |
| unicode | `false` |
| haystack-path | [`sherlock.txt`](benchmarks/haystacks/sherlock.txt) |
| count | 510 |


**word-ending-n**

| Parameter | Value |
| --------- | ----- |
| full name | `imported/sherlock/word-ending-n` |
| model | [`count-spans`](MODELS.md#count-spans) |
| regex | `````\b\w+n\b````` |
| case-insensitive | `false` |
| unicode | `false` |
| haystack-path | [`sherlock.txt`](benchmarks/haystacks/sherlock.txt) |
| count | 35297 |


**repeated-class-negation**

| Parameter | Value |
| --------- | ----- |
| full name | `imported/sherlock/repeated-class-negation` |
| model | [`count-spans`](MODELS.md#count-spans) |
| regex | `````[a-q][^u-z]{13}x````` |
| case-insensitive | `false` |
| unicode | `false` |
| haystack-path | [`sherlock.txt`](benchmarks/haystacks/sherlock.txt) |
| count | 2130 |


**ing-suffix**

| Parameter | Value |
| --------- | ----- |
| full name | `imported/sherlock/ing-suffix` |
| model | [`count-spans`](MODELS.md#count-spans) |
| regex | `````[a-zA-Z]+ing````` |
| case-insensitive | `false` |
| unicode | `false` |
| haystack-path | [`sherlock.txt`](benchmarks/haystacks/sherlock.txt) |
| count | 20547 |


**ing-suffix-limited-space**

| Parameter | Value |
| --------- | ----- |
| full name | `imported/sherlock/ing-suffix-limited-space` |
| model | [`count-spans`](MODELS.md#count-spans) |
| regex | `````\s[a-zA-Z]{0,12}ing\s````` |
| case-insensitive | `false` |
| unicode | `false` |
| haystack-path | [`sherlock.txt`](benchmarks/haystacks/sherlock.txt) |
| count | 19658 |


</details>

### opt

#### accelerate

These benchmarks test an optimization only present in full DFAs where some
states get "accelerated." Namely, this happens when a state has only a few
transitions that leave the state and where all other transitions point back to
the same state. When this happens, fast vectorized routines like `memchr` can
be used to look for just the outgoing transitions because otherwise the search
will just stay in the same state.

This optimization only applies when full DFAs are used because it requires
knowing ahead of the time the full set of transitions for a state. Since things
like the lazy DFA compute their transitions lazily, this technique can't
(easily) be applied there. Since building full DFAs is extremely expensive, it
is only done for very small regexes. Therefore, this optimization is somewhat
limited in scope.

| Engine | whole-line | non-dna |
| - | - | - |
| pcre2/jit | 991.9 MB/s | **3.9 GB/s** |
| re2 | 482.4 MB/s | 317.9 MB/s |
| rust/regex/dense | **1551.2 MB/s** | 1809.0 MB/s |
| rust/regex/meta | 1278.1 MB/s | 1820.8 MB/s |

<details>
<summary>Show individual benchmark parameters.</summary>

**whole-line**

| Parameter | Value |
| --------- | ----- |
| full name | `opt/accelerate/whole-line` |
| model | [`grep`](MODELS.md#grep) |
| regex | `````(?m)^.*$````` |
| case-insensitive | `false` |
| unicode | `false` |
| haystack-path | [`rust-src-tools-3b0d4813.txt`](benchmarks/haystacks/rust-src-tools-3b0d4813.txt) |
| count | 239963 |

This just tries to match an entire line with line anchors. The DFA sees that
`.` can't match `\n` but otherwise will match everything. So the DFA will pass
`\n` to `memchr` to quickly find the end of the line.

**non-dna**

| Parameter | Value |
| --------- | ----- |
| full name | `opt/accelerate/non-dna` |
| model | [`count-spans`](MODELS.md#count-spans) |
| regex | `````>[^\n]*\n\|\n````` |
| case-insensitive | `false` |
| unicode | `false` |
| haystack-path | [`imported/regex-redux-100000.fasta`](benchmarks/haystacks/imported/regex-redux-100000.fasta) |
| count | 16745 |

This regex was taken from the `regex-redux` benchmark. It is used at the
beginning of that benchmark to remove all line terminators and lines beginning
with `>`. The result is a flattened string of nucleotides.

The DFA is able to accelerate the `[^\n]*\n` construction by feeding `\n` and
`>` to `memchr2`. It does the same for the reverse DFA. Why `>`? Well, this is
an unanchored regex, so if the regex stumbles on a `>`, then that could start a
new match. So that transitions to some other state in the DFA.

</details>

#### backtrack

These benchmarks demonstrate the "bounded backtracking" optimization. This
optimization actually causes the regex crate, which is principally based
on finite automata, to use backtracking! It turns out the backtracking can
actually be quite fast in a lot of cases. Of course, its main problem is that
its worst case time complexity is exponential, and it can be difficult to
predict when exactly it will hit that worst case.

The regex crate mitigates the worst case by placing a bound on how much
backtracking can occur. Namely, it ensures that every byte in the haystack
is visited at most once by each NFA state. It does this by keeping track of
which combinations have been visited via a bitset. Thus, bounding backtracking
in this way requires `O(m*n)` space, where `m ~ len(regex)` and `n ~
len(haystack)`. Since either (or both) regex and haystack can get quite large,
the backtracking optimization is only used when `len(regex) * len(pattern)` is
below some heuristic limit.

This limit is in part why we use the `grep-captures` model. Namely, it ensures
the actual haystack that gets searched is quite small by capping it to the
length of a line, while still reflecting a real world use case.

We are also careful to:

1. Use a somewhat small regex, especially with Unicode enabled, or else it's
likely to go over the limits and thus disable the backtracking optimization.
2. Ensure the regex is not one-pass, or else we'll be measuring that
optimization instead of backtracking.
3. Benchmark the backtracking engine directly, to ensure it can be succesfully
used without hitting any limits. Otherwise, the meta regex engine will
transparently use another engine (probably the PikeVM).
4) In the Unicode Russian benchmark below, we use a Unicode-aware word boundary
which inhibits the use of a DFA and means the backtracking optimization is even
more critical.

Overall the backtracker usually edges out the PikeVM by about 2x or so. It's
not earth shattering, but it does help in a lot of cases.

| Engine | words-english | words-russian |
| - | - | - |
| go/regexp | 31.6 MB/s | - |
| pcre2/jit | **212.7 MB/s** | - |
| python/re | 27.3 MB/s | - |
| python/regex | - | 30.5 MB/s |
| re2 | 117.0 MB/s | - |
| regress | 86.0 MB/s | - |
| rust/regex | 156.0 MB/s | 37.9 MB/s |
| rust/regex/backtrack | 56.3 MB/s | **40.4 MB/s** |
| rust/regex/meta | 203.8 MB/s | 40.1 MB/s |
| rust/regex/pikevm | 29.5 MB/s | 23.2 MB/s |

<details>
<summary>Show individual benchmark parameters.</summary>

**words-english**

| Parameter | Value |
| --------- | ----- |
| full name | `opt/backtrack/words-english` |
| model | [`grep-captures`](MODELS.md#grep-captures) |
| regex | `````\b(?:(\w{6})\|(\w{5}))\b````` |
| case-insensitive | `false` |
| unicode | `false` |
| haystack-path | [`opensubtitles/en-huge.txt`](benchmarks/haystacks/opensubtitles/en-huge.txt) |
| count | 40536 |

This just looks for words of length 6 or 5. Everything here is just ASCII
aware.

**words-russian**

| Parameter | Value |
| --------- | ----- |
| full name | `opt/backtrack/words-russian` |
| model | [`grep-captures`](MODELS.md#grep-captures) |
| regex | `````\b(?:([\w&&\p{Cyrillic}]{6})\|([\w&&\p{Cyrillic}]{5}))\b````` |
| case-insensitive | `false` |
| unicode | `true` |
| haystack-path | [`opensubtitles/ru-huge.txt`](benchmarks/haystacks/opensubtitles/ru-huge.txt) |
| count | 27996 |

Like `words-english`, but makes everything Unicode aware. We also limit our
word characters to those that are also Cyrillic given that our haystack is
mostly written in a Cyrillic script.

Sadly very few regex engines support things like `[\w&&\p{Cyrillic}]`,
yet, that syntax is incredibly useful for situations like this. Namely,
`[\w&&\p{Cyrillic}]` is far smaller than `\w`, by about an order of magnitude.
And we just don't need the full `\w` here. Just the subset that is Cyrillic.

</details>

#### fixed-length

These benchmarks test "fixed length" optimizations. That is, for regexes with
no unbounded repetitions, one can compute the minimum and maximum lengths
that they can match. From those properties, one can sometimes reject a search
immediately based purely on the length of the haystack. The main complication
here is making sure things like a Unicode aware `.` contributes 4 to the
maximum since it could match up to 4 UTF-8 code units.

For minimums, things are relatively straight-forward. If your regex is
guaranteed to match at least 10 bytes and your haystack is less than that,
well, you can bail immediately.

Maximums are a little more tricky. Namely, if your regex is guaranteed to
match no more than 10 bytes and your haystack is longer than that, then you
can't necessarily bail because the regex could match anywhere. Thus, the
maximum optimization only kicks in when the regex is fully anchored at both
the start and end. In that case, the length of the haystack corresponds to
precisely how much the regex must match in order for a match to be reported
at all. And in that case, the maximum optimization kicks in.

| Engine | too-small-ascii | too-small-unicode | too-big-ascii | too-big-unicode | go33484-1 | go33484-2 | go33484-3 |
| - | - | - | - | - | - | - | - |
| go/regexp | **357.6 MB/s** | - | 238.4 MB/s | - | 163.4 GB/s | 62.1 GB/s | 1538.2 MB/s |
| re2 | 130.0 MB/s | - | 679.3 MB/s | - | 211.7 GB/s | 227.2 GB/s | 3.3 GB/s |
| rust/regex/hybrid | 228.9 MB/s | 562.8 MB/s | 935.7 MB/s | 635.8 MB/s | 372.5 GB/s | 423.3 GB/s | 3.0 GB/s |
| rust/regex/meta | 336.6 MB/s | **2019.5 MB/s** | **2.7 GB/s** | **2.3 GB/s** | **517.4 GB/s** | **517.4 GB/s** | **51.7 GB/s** |

<details>
<summary>Show individual benchmark parameters.</summary>

**too-small-ascii**

| Parameter | Value |
| --------- | ----- |
| full name | `opt/fixed-length/too-small-ascii` |
| model | [`count`](MODELS.md#count) |
| regex | `````\w{10,}````` |
| case-insensitive | `false` |
| unicode | `false` |
| haystack | `abcdef` |
| count | 0 |

This benchmark tests that the regex engine fails very quickly when it knows
that a match is impossible because the haystack is too small. In this case,
the regex needs to match at least 10 word ASCII bytes, but the haystack is
shorter than that. You can see the difference between `rust/regex/meta` and
`rust/regex/hybrid` for example.

**too-small-unicode**

| Parameter | Value |
| --------- | ----- |
| full name | `opt/fixed-length/too-small-unicode` |
| model | [`count`](MODELS.md#count) |
| regex | `````[\p{math}&&\u{10000}-\u{10FFFF}]{10,}````` |
| case-insensitive | `false` |
| unicode | `true` |
| haystack | `𝛃𝛃𝛃𝛃𝛃𝛃𝛃𝛃𝛃` |
| count | 0 |

Same idea as `too-small-ascii`, but for Unicode.

We specifically use a codepoint that uses 4 bytes per encoding to ensure that
the maximum length computation for a Unicode-aware class is correct. And in
particular, we construct the class such that it only matches codepoints that
are encoded with 4 bytes. So the 9 instances of 𝛃 make up 36 bytes, which is 4
fewer than the minimum of 40 computed by the regex.

Sadly, the class intersection syntax isn't well supported, so we only measure
the regex crate. We could probably use a simpler regex with some effort, but
¯\\\_(ツ)_/¯.

**too-big-ascii**

| Parameter | Value |
| --------- | ----- |
| full name | `opt/fixed-length/too-big-ascii` |
| model | [`count`](MODELS.md#count) |
| regex | `````^\w{30}$````` |
| case-insensitive | `false` |
| unicode | `false` |
| haystack | `abcdefghijklmnopqrstuvwxyzabcdefghijklmnopqrstuvwxyz` |
| count | 0 |

This checks that we bail early when we know the haystack is too big to match.

**too-big-unicode**

| Parameter | Value |
| --------- | ----- |
| full name | `opt/fixed-length/too-big-unicode` |
| model | [`count`](MODELS.md#count) |
| regex | `````^\w{10}$````` |
| case-insensitive | `false` |
| unicode | `true` |
| haystack | `𝛃𝛃𝛃𝛃𝛃𝛃𝛃𝛃𝛃𝛃𝛃` |
| count | 0 |

Same idea as `too-big-ascii`, but for Unicode.

**go33484-1**

| Parameter | Value |
| --------- | ----- |
| full name | `opt/fixed-length/go33484-1` |
| model | [`count`](MODELS.md#count) |
| regex | `````^a{2,5}$````` |
| case-insensitive | `false` |
| unicode | `false` |
| haystack | `aaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaa [.. snip ..]` |
| count | 0 |

This comes from: https://github.com/golang/go/issues/33484

**go33484-2**

| Parameter | Value |
| --------- | ----- |
| full name | `opt/fixed-length/go33484-2` |
| model | [`count`](MODELS.md#count) |
| regex | `````^((aaa)\|(aa))$````` |
| case-insensitive | `false` |
| unicode | `false` |
| haystack | `aaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaa [.. snip ..]` |
| count | 0 |

This comes from: https://github.com/golang/go/issues/33484

**go33484-3**

| Parameter | Value |
| --------- | ----- |
| full name | `opt/fixed-length/go33484-3` |
| model | [`count`](MODELS.md#count) |
| regex | `````^.{249}$````` |
| case-insensitive | `false` |
| unicode | `true` |
| haystack | `aaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaa [.. snip ..]` |
| count | 0 |

This comes from: https://github.com/golang/go/issues/33484

It was adapted slightly with a repetition to make the difference a bit more
noticeable.

</details>

#### literal-alt

These benchmarks demonstrate regex-automata's "literal alternation"
optimization. Namely, the optimization proceeds by tranforming a regex like
`zapper|z|zap` into `z(?:apper||ap)`. In effect, it pushes what is one very
large alternation down as far as it can. When matching the regex, especially
with an engine like the PikeVM, that initial large alternation can utterly
trash perf because the regex engine is shuffling states around for the one big
alternation for every byte of the haystack. But by pushing the branches down,
most bytes of the haystack are dealing with a much smaller branch and thus less
state shuffling.

This has an **enormous** impact on perf. And in the two benchmarks below, we
can observe the difference. In `one-pattern`, we join the dictionary into a
single pattern with `|`. But in the `pattern-per-word` benchmark, we treat
each word in the dictionary as its own pattern. The optimization described
above doesn't apply in the latter case. (It hasn't been attempted and I'm not
sure it's possible, since you need to preserve distinct match states for each
pattern.)

| Engine | one-pattern | pattern-per-word |
| - | - | - |
| go/regexp | 464.3 KB/s | - |
| re2 | 3.5 MB/s | - |
| rust/regex/hybrid | 614.1 MB/s | - |
| rust/regex/meta | **686.0 MB/s** | **403.1 MB/s** |
| rust/regex/pikevm | 32.7 MB/s | 166 B/s |

<details>
<summary>Show individual benchmark parameters.</summary>

**one-pattern**

| Parameter | Value |
| --------- | ----- |
| full name | `opt/literal-alt/one-pattern` |
| model | [`count`](MODELS.md#count) |
| regex-path | [`dictionary/english/length-15.txt`](benchmarks/regexes/dictionary/english/length-15.txt) |
| case-insensitive | `false` |
| unicode | `true` |
| haystack-path | [`opensubtitles/en-tiny.txt`](benchmarks/haystacks/opensubtitles/en-tiny.txt) |
| count | 1 |


**pattern-per-word**

| Parameter | Value |
| --------- | ----- |
| full name | `opt/literal-alt/pattern-per-word` |
| model | [`count`](MODELS.md#count) |
| regex-path | [`dictionary/english/length-15.txt`](benchmarks/regexes/dictionary/english/length-15.txt) |
| case-insensitive | `false` |
| unicode | `true` |
| haystack-path | [`opensubtitles/en-tiny.txt`](benchmarks/haystacks/opensubtitles/en-tiny.txt) |
| count | 1 |


</details>

#### onepass

These benchmarks test the "one-pass" DFA optimization. A one-pass NFA (before
being turned into a one-pass DFA) has the special property that at any point
during matching, there is at most one NFA state that can be transitioned to
from the current state. (Typically there may be many.) When this property
holds, the state shuffling done by the PikeVM to guarantee linear time can
be omitted entirely. We then capitalize on this absence of state shuffling
by turning the NFA into a DFA. It results in more memory usage but a much
faster search. And in particular, because of the one-pass property, there is at
most one DFA state for every NFA state. So there is no worst cast exponential
time/space complexity to worry about here that would otherwise apply to general
NFA-to-DFA conversion.

Note that RE2 calls this a "one-pass NFA" internally where as the regex crate
calls it a "one-pass DFA." Both are correct in some sense. One-pass NFA more
precisely refers to the formulation of the property, but I chose to call it a
DFA because its execution model more closely resembles that of a DFA. Namely,
every state transition is executed in a constant number of instructions, where
as this is generally not true for an NFA. (I'm being a bit hand-wavy here, bit
parallel NFAs would like to have a word with that generalization.)

The one-pass DFA occupies an important niche in the regex crate. Namely, it
has two critical powers that lazy and full DFAs do not have: it can match
Unicode word boundaries on all haystacks and it can resolve capture groups.
Normally, if we need to match Unicode word boundaries on non-ASCII text or
resolve capture groups, then we would otherwise be forced to resort to the
PikeVM or the bounded backtracker. Both of them are generally slower than the
one-pass DFA. Indeed, the benchmarks here include the PikeVM and the bounded
backtracker to demonstrate the difference.

Note that we benchmark the one-pass DFA explicitly to ensure that it
always works. If the regex in a benchmark changes or something about the
implementation changes to make the regex no longer one-pass, then the benchmark
will fail. In contrast, the regex crate API will not fail. It will just
silently not use the onepass DFA. We want the failure to surface and smack us
in the face.

| Engine | fn-predicate | first-three-words-english | first-three-words-russian | word-boundary-english | word-boundary-russian |
| - | - | - | - | - | - |
| go/regexp | 352.7 MB/s | 90.3 MB/s | - | - | - |
| pcre2/jit | **1294.6 MB/s** | **637.0 MB/s** | **808.9 MB/s** | **1206.7 MB/s** | **1317.3 MB/s** |
| python/re | 76.6 MB/s | 43.7 MB/s | - | - | - |
| python/regex | - | - | 78.4 MB/s | 67.8 MB/s | 135.4 MB/s |
| re2 | 754.8 MB/s | 460.6 MB/s | - | - | - |
| regress | 183.8 MB/s | 144.4 MB/s | - | - | - |
| rust/regex/backtrack | 374.0 MB/s | 234.9 MB/s | 265.9 MB/s | 617.1 MB/s | 716.1 MB/s |
| rust/regex/meta | 1031.1 MB/s | 513.1 MB/s | 603.1 MB/s | 842.5 MB/s | 1033.7 MB/s |
| rust/regex/onepass | 1029.6 MB/s | 546.7 MB/s | 700.6 MB/s | 969.4 MB/s | 1218.3 MB/s |
| rust/regex/pikevm | 148.7 MB/s | 90.1 MB/s | 106.9 MB/s | 263.5 MB/s | 284.0 MB/s |
| rust/regexold | - | - | - | 300.0 MB/s | 551.9 MB/s |

<details>
<summary>Show individual benchmark parameters.</summary>

**fn-predicate**

| Parameter | Value |
| --------- | ----- |
| full name | `opt/onepass/fn-predicate` |
| model | [`grep-captures`](MODELS.md#grep-captures) |
| regex | `````^\s*fn\s+(is_([^\(]+))\(([^)]+)\) -> bool \{$````` |
| case-insensitive | `false` |
| unicode | `false` |
| haystack-path | [`rust-src-tools-3b0d4813.txt`](benchmarks/haystacks/rust-src-tools-3b0d4813.txt) |
| count | 916 |

This benchmark just tries to extract some properties of a subset of functions
from a pile of Rust source code. We use capture groups to get the function name
and parameters.

**first-three-words-english**

| Parameter | Value |
| --------- | ----- |
| full name | `opt/onepass/first-three-words-english` |
| model | [`grep-captures`](MODELS.md#grep-captures) |
| regex | `````^ *(\w+) +(\w+) +(\w+)````` |
| case-insensitive | `false` |
| unicode | `false` |
| haystack-path | [`opensubtitles/en-huge.txt`](benchmarks/haystacks/opensubtitles/en-huge.txt) |
| count | 35128 |

This benchmark looks for the first three "words" in each line, and captures
each word. This is a bit of a higher match count than `fn-predicate`, so its
throughput is overall lower.

**first-three-words-russian**

| Parameter | Value |
| --------- | ----- |
| full name | `opt/onepass/first-three-words-russian` |
| model | [`grep-captures`](MODELS.md#grep-captures) |
| regex | `````^ *(\w+) +(\w+) +(\w+)````` |
| case-insensitive | `false` |
| unicode | `true` |
| haystack-path | [`opensubtitles/ru-huge.txt`](benchmarks/haystacks/opensubtitles/ru-huge.txt) |
| count | 19224 |

This is the same as `first-three-words-english`, but enables Unicode and runs
it on a Russian corpus. Engines like the PikeVM tend to slow down here because
the `\w` class is much bigger and requires more state shuffling.

**word-boundary-english**

| Parameter | Value |
| --------- | ----- |
| full name | `opt/onepass/word-boundary-english` |
| model | [`grep-captures`](MODELS.md#grep-captures) |
| regex | `````^(\S{8})(\S)\b````` |
| case-insensitive | `false` |
| unicode | `false` |
| haystack-path | [`opensubtitles/en-huge.txt`](benchmarks/haystacks/opensubtitles/en-huge.txt) |
| count | 579 |

This benchmark uses an ASCII word boundary to find all 9 letter words that
occur at the beginning of a line, while capturing the first 8 letters and last
letter separately. Mostly this is meant to serve as an interesting comparison
point to to `word-boundary-russian`, which is Unicode aware.

**word-boundary-russian**

| Parameter | Value |
| --------- | ----- |
| full name | `opt/onepass/word-boundary-russian` |
| model | [`grep-captures`](MODELS.md#grep-captures) |
| regex | `````^(\S{8})(\S)\b````` |
| case-insensitive | `false` |
| unicode | `true` |
| haystack-path | [`opensubtitles/ru-huge.txt`](benchmarks/haystacks/opensubtitles/ru-huge.txt) |
| count | 873 |

This is the same as the English counterpart, but enables Unicode mode and thus
uses Unicode-aware word boundaries. This demonstrates that the one-pass DFA
works with Unicode word boundaries on non-ASCII text. (It is the only DFA in
the regex crate that can do so.)

</details>

#### prefilter

These benchmarks demonstrate the prefix prefilter optimization. This is
the most "basic" of literal optimizations in that it looks for prefixes
that occur in every match of a regex, and then looks for occurrences of
those prefixes in the haystack. Occurrences are considered candidate matches
and must be confirmed by the regex engine. Upon failure, the prefilter is
usually restarted to look for more candidates. In general, this results is
significant (sometimes by orders of magnitude) speed improvements in many
cases. It can sometimes lead to slower searches if the false positive rate
of candidate matches is high. (For those, see the `folly` benchmarks in the
parent directory.)

Despite the seeming simplicity of this optimization, regex engines vary
in their sophistication. Some just look for a single byte prefix and use
memchr in that case, and then otherwise don't do much. The regex crate tries
quite hard to extract prefixes and has a couple different SIMD algorithms it
can employ, including for handling cases where there are multiple distinct
prefixes.

The trick is generally knowing when to stop. For example, you could generate
52 different prefixes all ending with `foo` for `[A-Za-z]foo\w+`, but that's
unlikely to be effective because as you increase the number of prefixes you
look for, you 1) generally do so at a slower speed and 2) risk the chance of
increasing your false positive rate.

Still... You don't necessarily want to find the fewest prefixes either. For
example, given something like `foo[a-c]`, you might actually want to look for
`{fooa, foob, fooc}`, as that set is still fairly small and might lead to a
lower false positive rate than just `foo`.

And still yet, you also want to generally prefer longer prefixes if you can.
For example, given `Sherlock|Holmes`, you might be tempted to just look for
occurrences of `S` and `H`. But if they are frequent in your haystack, that
might lead to a substantially higher false positive rate than just looking
for `{Sherlock, Holmes}`.

In other words, this is basically a dark art and is really just a whole pile
of heuristics that seem to work well empirically.

| Engine | literal-english | literal-casei-english | literal-russian | literal-casei-russian | rust-functions |
| - | - | - | - | - | - |
| go/regexp | 28.1 GB/s | 44.1 MB/s | 3.2 GB/s | 32.8 MB/s | 2.6 GB/s |
| pcre2/jit | 37.1 GB/s | **23.8 GB/s** | **44.5 GB/s** | **25.8 GB/s** | **21.0 GB/s** |
| python/re | 4.3 GB/s | 304.7 MB/s | 8.4 GB/s | 460.6 MB/s | - |
| python/regex | 4.1 GB/s | 3.9 GB/s | 4.8 GB/s | 5.3 GB/s | 2.5 GB/s |
| re2 | **48.1 GB/s** | 3.0 GB/s | 803.3 MB/s | 988.5 MB/s | 5.2 GB/s |
| regress | 3.6 GB/s | 1354.3 MB/s | 3.6 GB/s | 312.8 MB/s | 1989.4 MB/s |
| rust/memchr/memmem | 39.9 GB/s | - | 40.3 GB/s | - | - |
| rust/regex/meta | 41.5 GB/s | 17.3 GB/s | 40.5 GB/s | 13.5 GB/s | 14.1 GB/s |
| rust/regexold | 40.3 GB/s | 14.5 GB/s | 41.5 GB/s | 11.3 GB/s | 3.6 GB/s |

<details>
<summary>Show individual benchmark parameters.</summary>

**literal-english**

| Parameter | Value |
| --------- | ----- |
| full name | `opt/prefilter/literal-english` |
| model | [`count`](MODELS.md#count) |
| regex | `````Sherlock Holmes````` |
| case-insensitive | `false` |
| unicode | `false` |
| haystack-path | [`opensubtitles/en-huge.txt`](benchmarks/haystacks/opensubtitles/en-huge.txt) |
| count | 1 |


**literal-casei-english**

| Parameter | Value |
| --------- | ----- |
| full name | `opt/prefilter/literal-casei-english` |
| model | [`count`](MODELS.md#count) |
| regex | `````Sherlock Holmes````` |
| case-insensitive | `true` |
| unicode | `false` |
| haystack-path | [`opensubtitles/en-huge.txt`](benchmarks/haystacks/opensubtitles/en-huge.txt) |
| count | 1 |


**literal-russian**

| Parameter | Value |
| --------- | ----- |
| full name | `opt/prefilter/literal-russian` |
| model | [`count`](MODELS.md#count) |
| regex | `````Шерлок Холмс````` |
| case-insensitive | `false` |
| unicode | `true` |
| haystack-path | [`opensubtitles/ru-huge.txt`](benchmarks/haystacks/opensubtitles/ru-huge.txt) |
| count | 1 |

This measures a non-ASCII literal on a non-ASCII haystack. Regex engines that
naively just feed the first byte to memchr get wrecked on this benchmark by a
high false positive rate, because they wind up using a UTF-8 leading byte that
occurs in almost every codepoint in the haystack.

**literal-casei-russian**

| Parameter | Value |
| --------- | ----- |
| full name | `opt/prefilter/literal-casei-russian` |
| model | [`count`](MODELS.md#count) |
| regex | `````Шерлок Холмс````` |
| case-insensitive | `true` |
| unicode | `true` |
| haystack-path | [`opensubtitles/ru-huge.txt`](benchmarks/haystacks/opensubtitles/ru-huge.txt) |
| count | 1 |


**rust-functions**

| Parameter | Value |
| --------- | ----- |
| full name | `opt/prefilter/rust-functions` |
| model | [`count-captures`](MODELS.md#count-captures) |
| regex | `````fn is_(\w+)\|fn as_(\w+)````` |
| case-insensitive | `false` |
| unicode | `false` |
| haystack-path | [`rust-src-tools-3b0d4813.txt`](benchmarks/haystacks/rust-src-tools-3b0d4813.txt) |
| count | 948 |

This is a mostly silly little benchmark that looks for a couple different
functions. This mostly checks whether regex engines do a literal scan for both
`fn is_` and `fn as_`, or just `fn `. (One doesn't seem obviously better than
the other. The former will have a lower false positive rate, but the latter is
likely to be much quicker at identifying candidates, depending on algorithm
choice.)

</details>

#### reverse-anchored

This benchmark demonstrates that if a regex is anchored at the end, then
regex-automata's meta engine will do a reverse search starting at the end to
look for a match. In contrast, lower level regex engines don't know about this
optimization and just naively scan starting at the beginning.

| Engine | word-end |
| - | - |
| go/regexp | 78.8 MB/s |
| pcre2/jit | 1645.4 MB/s |
| re2 | 12254.3 GB/s |
| rust/regex/hybrid | 829.3 MB/s |
| rust/regex/meta | **34493.5 GB/s** |

<details>
<summary>Show individual benchmark parameters.</summary>

**word-end**

| Parameter | Value |
| --------- | ----- |
| full name | `opt/reverse-anchored/word-end` |
| model | [`count-spans`](MODELS.md#count-spans) |
| regex | `````\w$````` |
| case-insensitive | `false` |
| unicode | `false` |
| haystack | `************************************************************ [.. snip ..]` |
| count | 1 |


</details>

#### reverse-inner

These benchmarks test the "reverse inner" literal optimization. This is very
much like the "reverse suffix" literal optimization, except it works on
literals that are neither prefixes or suffixes. It works by looking for a
literal that *must* appear in all matches and then splitting the regex into
pieces: a prefix regex, followed by the literal and then a suffix regex.

Candidate matches are found by searching for the literal, then doing a reverse
search from the start of the literal using the prefix regex and then finally a
full forward scan to find the end of the match.

This is quite a precarious optimization since quadratic behavior can occur
just like in the reverse suffix optimization. However, the quadratic behavior
can be more subtle because of the final forward scan to confirm the match.
Namely, when a match is not found, you need to know how far that scan looked in
the haystack to ensure you don't scan that region of the haystack again in a
subsequent reverse scan.

We test both forms of quadratic behavior below. In both cases, the regex engine
detects it and bails out of the optimization.

| Engine | holmes | email | factored-prefix | no-quadratic-backward | no-quadratic-forward |
| - | - | - | - | - | - |
| go/regexp | 34.2 MB/s | 46.6 MB/s | 17.1 MB/s | 137.5 MB/s | 44.6 MB/s |
| pcre2/jit | 375.7 MB/s | 641.4 MB/s | 169.4 MB/s | **4.8 GB/s** | **1883.8 MB/s** |
| re2 | 967.9 MB/s | 983.6 MB/s | 924.4 MB/s | 987.0 MB/s | 987.0 MB/s |
| rust/regex/hybrid | 815.9 MB/s | 826.6 MB/s | 800.0 MB/s | 825.7 MB/s | 825.7 MB/s |
| rust/regex/meta | **19.2 GB/s** | **81.7 GB/s** | **9.4 GB/s** | 823.0 MB/s | 406.0 MB/s |

<details>
<summary>Show individual benchmark parameters.</summary>

**holmes**

| Parameter | Value |
| --------- | ----- |
| full name | `opt/reverse-inner/holmes` |
| model | [`count-spans`](MODELS.md#count-spans) |
| regex | `````\w+\s+Holmes\s+\w+````` |
| case-insensitive | `false` |
| unicode | `false` |
| haystack-path | [`sherlock.txt`](benchmarks/haystacks/sherlock.txt) |
| count | 2593 |

A regex that looks for any words preceding and following `Holmes`. The reverse
inner literal scan is able to very quickly look for matches of `Holmes`, then
do a reverse scan for `\w+\s+` to find the start of the match, and finally a
foward scan for `\s+\w+` to find the end of the match.

**email**

| Parameter | Value |
| --------- | ----- |
| full name | `opt/reverse-inner/email` |
| model | [`count-spans`](MODELS.md#count-spans) |
| regex | `````\w+@\w+````` |
| case-insensitive | `false` |
| unicode | `false` |
| haystack-path | [`rust-src-tools-3b0d4813.txt`](benchmarks/haystacks/rust-src-tools-3b0d4813.txt) |
| count | 47 |

A very simple regex for matching things that might be email addresses. The
"reverse inner" optimization shines here because `@` is pretty rare and there
is no overlap between `\w` and `@`, so quadratic behavior is impossible.
In this particularly ideal case, the regex crate absolutely screams. On my
system, even though the hybrid engine is at a respectable ~800 MB/s throughput,
this optimization bumps it up to ~80 GB/s, an improvement of two orders of
magnitude.

**factored-prefix**

| Parameter | Value |
| --------- | ----- |
| full name | `opt/reverse-inner/factored-prefix` |
| model | [`count-spans`](MODELS.md#count-spans) |
| regex | `````\pL+herloc\pL+\|\pL+olme\pL+````` |
| case-insensitive | `false` |
| unicode | `true` |
| haystack-path | [`sherlock.txt`](benchmarks/haystacks/sherlock.txt) |
| count | 3542 |

This benchmark also uses the reverse inner optimization, and does despite
there not *appearing* to be a top-level concatenation. Namely, at the time of
writing, the reverse inner literal detection is not supremely dumb, but also
not particularly smart either. It only looks for a top-level concatenation, and
in that concatenation, looks for required literals. But if the regex just has
an alternation at the top, it bails out.

The trick here is that the HIR smart constructors in the `regex-syntax` crate
will notice that each branch of the alternation has a common prefix and factor
it out. So the regex gets rewritten as `\pL+(?:herloc\pL+|olme\p+)`. (Common
suffix factoring doesn't exist at the time of writing.) This transforms
the regex from one with a top-level alternation to one with a top-level
concatenation, and thus amenable to the not-so-smart reverse inner literal
extraction.

**no-quadratic-backward**

| Parameter | Value |
| --------- | ----- |
| full name | `opt/reverse-inner/no-quadratic-backward` |
| model | [`count-spans`](MODELS.md#count-spans) |
| regex | `````[A-Z].*bcdefghijklmnopq[a-z]+````` |
| case-insensitive | `false` |
| unicode | `false` |
| haystack | `bcdefghijklmnopqbcdefghijklmnopqbcdefghijklmnopqbcdefghijklm [.. snip ..]` |
| count | 0 |

This benchmark checks that the reverse inner optimization does not result
in quadratic behavior within a single search. This specifically looks for
quadratic behavior that occurs from the reverse search after finding a literal
candidate backs up too far (past the previous literal candidate).

The mitigation technique is to detect the quadratic behavior and bail out of
the reverse inner optimization and use a normal forward search instead.

See also the `opt/reverse-suffix/no-quadratic` benchmark for a bit more
explanation. The optimization is a little different but the mechanism for
quadratic behavior is very similar.

**no-quadratic-forward**

| Parameter | Value |
| --------- | ----- |
| full name | `opt/reverse-inner/no-quadratic-forward` |
| model | [`count-spans`](MODELS.md#count-spans) |
| regex | `````.efghijklmnopq[a-z]+[A-Z]````` |
| case-insensitive | `false` |
| unicode | `false` |
| haystack | `bcdefghijklmnopqbcdefghijklmnopqbcdefghijklmnopqbcdefghijklm [.. snip ..]` |
| count | 0 |

This benchmark also checks that quadratic behavior does not occur. Unlike
the backward case above, this checks that a *second* way quadratic behavior
*could* occur. Namely, in this case, the problem isn't the reverse scan,
but the forward scan that occurs following the reverse scan. (Remember, the
opptimization works by finding literal candidates, then a reverse scan to find
the start position and finally a forward scan to find the end position. This
benchmark is about that final forward scan.)

Namely, it is possible that the forward scan looks ahead to the end of the
haystack but then doesn't find a match. And indeed, that's exactly how we craft
our benchmark here. Without a mitigation in place, this would find many literal
candidates that also match the reverse scan, but then don't match the forward
scan only after scanning to the end of the haystack. This then repeats itself
and you wind up with quadratic behavior.

The way we prevent this is to track how far the forward scan gets to when it
fails. Then, after we find our next literal candidate, we instruct the reverse
scan to avoid scanning past the previous position at which the forward scan
fails. If it does reach that position, then we know we've potentially triggered
quadratic behavior.

</details>

#### reverse-suffix

These benchmarks test the "reverse suffix" optimization. This works by looking
for a suffix literal that must occur at the end of every match, searching for
that literal and then doing a reverse DFA scan to confirm any candidates that
were found from the literal scan.

The main downside of this approach is that it opens you up to quadratic
behavior. The `no-quadratic` benchmark below demonstrates that we mitigate
against that.

| Engine | holmes | no-quadratic |
| - | - | - |
| go/regexp | 33.8 MB/s | 138.5 MB/s |
| pcre2/jit | 370.8 MB/s | **4.8 GB/s** |
| re2 | 945.8 MB/s | 987.0 MB/s |
| rust/regex/hybrid | 806.6 MB/s | 824.8 MB/s |
| rust/regex/meta | **17.1 GB/s** | 820.4 MB/s |

<details>
<summary>Show individual benchmark parameters.</summary>

**holmes**

| Parameter | Value |
| --------- | ----- |
| full name | `opt/reverse-suffix/holmes` |
| model | [`count-spans`](MODELS.md#count-spans) |
| regex | `````\w+\s+Holmes````` |
| case-insensitive | `false` |
| unicode | `false` |
| haystack-path | [`sherlock.txt`](benchmarks/haystacks/sherlock.txt) |
| count | 4073 |

A regex that looks for any words preceding `Holmes`. The reverse suffix
literal scan is able to very quickly look for matches of `Holmes`, then do a
reverse scan for `\w+\s+` to find the start of the match.

**no-quadratic**

| Parameter | Value |
| --------- | ----- |
| full name | `opt/reverse-suffix/no-quadratic` |
| model | [`count-spans`](MODELS.md#count-spans) |
| regex | `````[A-Z].*bcdefghijklmnopq````` |
| case-insensitive | `false` |
| unicode | `false` |
| haystack | `bcdefghijklmnopqbcdefghijklmnopqbcdefghijklmnopqbcdefghijklm [.. snip ..]` |
| count | 0 |

This benchmark checks that the reverse suffix optimization does not result in
quadratic behavior within a single search. Namely, this benchmark is designed
such that the suffix literal matches many times, and at each point, the reverse
scan to confirm that match will continue all the way back to the beginning of
the haystack. Without some kind of mitigation for this, it would result in
quadratic behavior in the size of the haystack.

There is no real way to get a point of reference for this. The only way to see
the difference is to remove the mitigation within the meta regex engine and
re-run the benchmark. Indeed, it shows a perf reduction by about two orders of
magnitude.

Currently, the mitigation is that the reverse search will stop itself before it
reaches any point in the haystack that has already been scanned. In that case,
the optimization will fail and a normal forward search will be used.

Another possible mitigation is to analyze the regex to check that there is no
way for the literal search to overlap with the reverse scan to confirm the
match. Indeed, this regex would fail that test since `.*` will happily match
the literal `bcdefghi...`. The problem with that approach in general is that
even if there is overlap, that doesn't mean a search will result in quadratic
behavior. There isn't too much downside to just trying and bailing out when we
detect it, other than code complexity. But the upside is that the optimization
will apply even when there is overlap.

</details>

### reported

#### i787-keywords

These benchmarks came from: https://github.com/rust-lang/regex/issues/787

This regex is a common sort of occurrence where someone puts a bunch of
literals in an alternation and wraps them in word boundary assertions. The main
issue for the regex crate is the Unicode case (which is the default). Namely,
Unicode word boundaries can't be handled by the DFAs on non-ASCII haystacks,
so perf can get trashed because the regex crate has to fall back to a slower
engine (like the PikeVM).

In the old regex crate, this was made doubly worse because the PikeVM isn't
great at dealing with large alternations. But in the rewrite, literal
alternations are rewritten in a more optimized way that pushes the branching
down more. (See the `opt/literal-alt` benchmarks for more on that.)

Another problem in the old regex crate is that it had trouble with prefilters
in regexes surrounded by look-around assertions, primarily because its internal
engine APIs were not principled about separating "search the haystack" and
"search the haystack at this range while taking the surrounding context into
account in order to correctly compute look-around assertions."

So in the regex crate rewrite, these things were all fixed. And now both
cases will use Teddy because of the extracted prefilter... But... Ug. Sadly,
Teddy doesn't do so hot on this particular benchmark. Profiling suggests it
gets stuck in its verification step, which is quite unfortunate, because an
Aho-Corasick DFA (or even lazy DFA) do much better here.

Unless we can fix Teddy, the ideal scenario here is that we just use the lazy
DFA for the ASCII case and an Aho-Corasick DFA prefilter for the Unicode case.
Why the difference? Because without the prefilter for the Unicode case, the
lazy DFA will quit once it sees a non-ASCII byte in the haystack, and there are
a number of them here. The prefilter avoids that quitting problem and instead
just uses lazy DFA for confirming the match. (Which could still quit, but it's
far less likely to because the alternation is just a bunch of ASCII words.)
Unfortunately, it seems tricky to figure out a good heuristic that selects our
ideal scenario.

The Teddy engine may be difficult to fix in this particular case because the
match count is pretty high.

| Engine | compile | ascii | unicode | opt-ascii | opt-unicode |
| - | - | - | - | - | - |
| go/regexp | 69.85us | 8.9 MB/s | - | 14.1 MB/s | - |
| hyperscan | 9.40ms | 416.9 MB/s | - | 370.5 MB/s | - |
| pcre2/jit | 26.51us | 223.1 MB/s | **176.4 MB/s** | 284.6 MB/s | 214.4 MB/s |
| python/re | 231.56us | 30.8 MB/s | - | 72.9 MB/s | - |
| python/regex | 921.22us | 26.3 MB/s | 26.8 MB/s | 41.2 MB/s | 41.9 MB/s |
| re2 | 39.37us | 462.1 MB/s | - | 461.8 MB/s | - |
| regress | 24.85us | 22.8 MB/s | - | 61.8 MB/s | - |
| rust/regex/ast | **10.09us** | - | - | - | - |
| rust/regex/hir | 13.15us | - | - | - | - |
| rust/regex/meta | 285.29us | 175.6 MB/s | 174.1 MB/s | 359.0 MB/s | **360.7 MB/s** |
| rust/regex/nfa | 17.26us | - | - | - | - |
| rust/regexold | 55.66us | **636.1 MB/s** | 109.8 MB/s | **635.1 MB/s** | 179.0 MB/s |

<details>
<summary>Show individual benchmark parameters.</summary>

**compile**

| Parameter | Value |
| --------- | ----- |
| full name | `reported/i787-keywords/compile` |
| model | [`compile`](MODELS.md#compile) |
| regex-path | [`reported/i787-keywords.txt`](benchmarks/regexes/reported/i787-keywords.txt) |
| case-insensitive | `false` |
| unicode | `false` |
| haystack | `f64` |
| count | 1 |


**ascii**

| Parameter | Value |
| --------- | ----- |
| full name | `reported/i787-keywords/ascii` |
| model | [`count-spans`](MODELS.md#count-spans) |
| regex-path | [`reported/i787-keywords.txt`](benchmarks/regexes/reported/i787-keywords.txt) |
| case-insensitive | `false` |
| unicode | `false` |
| haystack-path | [`bstr-ext-slice-65993b58.txt`](benchmarks/haystacks/bstr-ext-slice-65993b58.txt) |
| count | 5674 |


**unicode**

| Parameter | Value |
| --------- | ----- |
| full name | `reported/i787-keywords/unicode` |
| model | [`count-spans`](MODELS.md#count-spans) |
| regex-path | [`reported/i787-keywords.txt`](benchmarks/regexes/reported/i787-keywords.txt) |
| case-insensitive | `false` |
| unicode | `true` |
| haystack-path | [`bstr-ext-slice-65993b58.txt`](benchmarks/haystacks/bstr-ext-slice-65993b58.txt) |
| count | 5674 |


**opt-ascii**

| Parameter | Value |
| --------- | ----- |
| full name | `reported/i787-keywords/opt-ascii` |
| model | [`count-spans`](MODELS.md#count-spans) |
| regex | `````\b(Self\|a(?:bstract\|s)\|b(?:ecome\|o(?:ol\|x)\|reak)\|c(?:har\|on(?:st\|tinue)\|rate)\|do\|e(?:lse\|num\|xtern)\|f(?:32\|64\|alse\|inal\|n\|or)\|i(?:1(?:28\|6)\|32\|64\|mpl\|size\|[8fn])\|l(?:et\|oop)\|m(?:a(?:cro\|tch)\|o(?:d\|ve)\|ut)\|override\|p(?:riv\|ub)\|re(?:f\|turn)\|s(?:elf\|t(?:atic\|r(?:(?:uct)?))\|uper)\|t(?:r(?:ait\|ue\|y)\|ype(?:(?:of)?))\|u(?:1(?:28\|6)\|32\|64\|8\|ns(?:afe\|ized)\|s(?:(?:(?:iz)?)e))\|virtual\|wh(?:(?:er\|il)e)\|yield)\b````` |
| case-insensitive | `false` |
| unicode | `false` |
| haystack-path | [`bstr-ext-slice-65993b58.txt`](benchmarks/haystacks/bstr-ext-slice-65993b58.txt) |
| count | 5674 |

This is the "optimized" variant of the regex as posted in the GitHub issue
linked above. I believe this isn't quite a correct transformation, since the
program that produced this variant gets rid of preference order. Nevertheless,
it's interesting to benchmark this and compare it to others. (Note that the
regex crate does its own internal rewriting of literal alternations like this,
but in a way that preserves preference order.)

**opt-unicode**

| Parameter | Value |
| --------- | ----- |
| full name | `reported/i787-keywords/opt-unicode` |
| model | [`count-spans`](MODELS.md#count-spans) |
| regex | `````\b(Self\|a(?:bstract\|s)\|b(?:ecome\|o(?:ol\|x)\|reak)\|c(?:har\|on(?:st\|tinue)\|rate)\|do\|e(?:lse\|num\|xtern)\|f(?:32\|64\|alse\|inal\|n\|or)\|i(?:1(?:28\|6)\|32\|64\|mpl\|size\|[8fn])\|l(?:et\|oop)\|m(?:a(?:cro\|tch)\|o(?:d\|ve)\|ut)\|override\|p(?:riv\|ub)\|re(?:f\|turn)\|s(?:elf\|t(?:atic\|r(?:(?:uct)?))\|uper)\|t(?:r(?:ait\|ue\|y)\|ype(?:(?:of)?))\|u(?:1(?:28\|6)\|32\|64\|8\|ns(?:afe\|ized)\|s(?:(?:(?:iz)?)e))\|virtual\|wh(?:(?:er\|il)e)\|yield)\b````` |
| case-insensitive | `false` |
| unicode | `true` |
| haystack-path | [`bstr-ext-slice-65993b58.txt`](benchmarks/haystacks/bstr-ext-slice-65993b58.txt) |
| count | 5674 |

Same as `opt-ascii`, but with Unicode mode enabled.

</details>

#### p893-hir-case-folding

This benchmark comes from: https://github.com/rust-lang/regex/pull/893

Specifically, the `subtract-empty` regex is what came out of that PR. The regex
is a delightfully pathological case, where the `--` (difference) character
class set operator is repeated over and over again. It repeatedly subtracts the
empty class from the one we started with, `[[:^spance:]]`. The crucial bit is
that case insensitive mode is enabled, and case folding is re-applied for every
single difference operation. Since case folding is not exactly cheap, this
results in quite a bit of time to parse a regex for a pattern that is not so
long.

The bottleneck lay in the AST->HIR translation layer, which takes a structured
representation of the concrete syntax and converts it into a high-level
intermediate representation. This is the point at which character classes are
flattened into ranges of non-overlapping codepoints. And of course, part of
that is doing Unicode case folding.

We fixed the particular case reported in PR #893 by adopting a technique from
the PR: we track whether an interval set has been case folded or not. Since
this property is preserved through all class operations (e.g., subtracting a
case folded set from another case folded set produces a case folded set), this
can actually save us from redoing case folding when applying the binary set
operations in a number of cases.

We also benchmark a different case, `repeated`, where the same (giant) class
is repeated over and over again. In this case, each class *has* to be case
folded individually. There is no opportunity (in the current implementation)
to avoid redoing case folding because the underlying interval set used to
combine character classes doesn't actually know that `\pL` is already case
folded.

In this case, we really just need to make case folding faster, which we did by
reducing the number of case folding table lookups. (Another idea from the patch
in PR #893.)

For the `repeated` case, since we are just repeating `\pL` over and over again,
it is in theory possible to introduce a sort of caching mechanism where you
recognize sets that have been case folded before and just reuse the result.
It's not actually totally clear how much this would help, and would likely be a
little tricky to do correctly. More to the point, even if you had a cache, the
regex crate supports enough distinct Unicode classes that you could just write
a distinct class instead of repeating the same one.

There's probably still some room for improvement here.

| Engine | subtract-empty | subtract-non-empty | repeated |
| - | - | - | - |
| rust/regex/hir | **2.17us** | **5.02us** | **3.74ms** |

<details>
<summary>Show individual benchmark parameters.</summary>

**subtract-empty**

| Parameter | Value |
| --------- | ----- |
| full name | `reported/p893-hir-case-folding/subtract-empty` |
| model | [`compile`](MODELS.md#compile) |
| regex | `````(?i:[[:^space:]------------------------------------------------------------------------])````` |
| case-insensitive | `false` |
| unicode | `true` |
| haystack | `a` |
| count | 1 |


**subtract-non-empty**

| Parameter | Value |
| --------- | ----- |
| full name | `reported/p893-hir-case-folding/subtract-non-empty` |
| model | [`compile`](MODELS.md#compile) |
| regex | `````(?i:[[:^space:]--a--a--a--a--a--a--a--a--a--a--a--a--a--a--a--a--a--a--a--a--a--a--a--a--a--a--a--a--a--a--a--a--a--a--a--a])````` |
| case-insensitive | `false` |
| unicode | `true` |
| haystack | `b` |
| count | 1 |


**repeated**

| Parameter | Value |
| --------- | ----- |
| full name | `reported/p893-hir-case-folding/repeated` |
| model | [`compile`](MODELS.md#compile) |
| regex | `````(?i:[\pL\pL\pL\pL\pL\pL\pL\pL\pL\pL\pL\pL\pL\pL\pL\pL\pL\pL\pL\pL\pL\pL\pL\pL\pL\pL\pL\pL\pL\pL\pL\pL\pL\pL\pL\pL\pL\pL\pL\pL\pL\pL\pL\pL\pL\pL\pL\pL\pL\pL\pL\pL\pL\pL\pL\pL\pL\pL\pL\pL\pL\pL\pL\pL\pL\pL\pL\pL\pL\pL\pL\pL])````` |
| case-insensitive | `false` |
| unicode | `true` |
| haystack | `b` |
| count | 1 |


</details>

### scratch

| Engine | dot |
| - | - |
| go/regexp | 3.4 MB/s |
| hyperscan | 80.5 MB/s |
| pcre2/jit | **84.7 MB/s** |
| python/re | 8.5 MB/s |
| re2 | 16.7 MB/s |
| rust/regex/meta | 41.1 MB/s |
| rust/regexold | 52.4 MB/s |

<details>
<summary>Show individual benchmark parameters.</summary>

**dot**

| Parameter | Value |
| --------- | ----- |
| full name | `scratch/dot` |
| model | [`count-spans`](MODELS.md#count-spans) |
| regex | `````.````` |
| case-insensitive | `false` |
| unicode | `true` |
| haystack | `abcdefghijabcdefghijabcdefghijabcdefghijabcdefghijabcdefghij [.. snip ..]` |
| count | 25000 |


</details>

### slow

| Engine | quadratic |
| - | - |
| go/regexp | 670 B/s |
| re2 | 240 B/s |
| rust/regex/meta | **848.3 KB/s** |
| rust/regex/pikevm | 349 B/s |

<details>
<summary>Show individual benchmark parameters.</summary>

**quadratic**

| Parameter | Value |
| --------- | ----- |
| full name | `slow/quadratic` |
| model | [`count`](MODELS.md#count) |
| regex | `````(?:A+){1000}\|````` |
| case-insensitive | `false` |
| unicode | `false` |
| haystack | `AAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAA [.. snip ..]` |
| count | 1000 |


</details>

### unicode

#### codepoints

| Engine | any-one | any-all | letters-one | letters-alt | letters-lower-or-upper | contiguous-greek |
| - | - | - | - | - | - | - |
| go/regexp | 25.7 MB/s | 162.5 MB/s | 34.6 MB/s | - | - | 213.1 MB/s |
| hyperscan | **670.9 MB/s** | - | - | - | - | - |
| pcre2 | - | - | - | - | - | 52.6 MB/s |
| pcre2/jit | 311.2 MB/s | 2.3 GB/s | **1002.3 MB/s** | - | 570.2 MB/s | 1047.5 MB/s |
| python/regex | 57.5 MB/s | **4.2 GB/s** | 990.4 MB/s | **18.0 GB/s** | 533.1 MB/s | **2.3 GB/s** |
| re2 | 63.7 MB/s | 492.3 MB/s | 3.1 MB/s | - | - | 981.1 MB/s |
| regress | - | - | - | - | - | 456.3 MB/s |
| rust/regex/meta | 356.0 MB/s | 399.2 MB/s | 12.8 MB/s | 7.4 MB/s | **822.7 MB/s** | 826.0 MB/s |

<details>
<summary>Show individual benchmark parameters.</summary>

**any-one**

| Parameter | Value |
| --------- | ----- |
| full name | `unicode/codepoints/any-one` |
| model | [`count`](MODELS.md#count) |
| regex | `````(?s:.)````` |
| case-insensitive | `false` |
| unicode | `true` |
| haystack-path | [`unicode/allcodepoints.txt`](benchmarks/haystacks/unicode/allcodepoints.txt) |
| count | 1112064 |


**any-all**

| Parameter | Value |
| --------- | ----- |
| full name | `unicode/codepoints/any-all` |
| model | [`count-spans`](MODELS.md#count-spans) |
| regex | `````(?s:.)+````` |
| case-insensitive | `false` |
| unicode | `true` |
| haystack-path | [`unicode/allcodepoints.txt`](benchmarks/haystacks/unicode/allcodepoints.txt) |
| count | 4382592 |


**letters-one**

| Parameter | Value |
| --------- | ----- |
| full name | `unicode/codepoints/letters-one` |
| model | [`count`](MODELS.md#count) |
| regex | `````\pL{100}````` |
| case-insensitive | `false` |
| unicode | `true` |
| haystack-path | [`unicode/allcodepoints.txt`](benchmarks/haystacks/unicode/allcodepoints.txt) |
| count(\*) | 1244 |
| count(go/regexp) | 1201 |
| count(pcre2/jit) | 1203 |

The `regress` engine is excluded because it doesn't support `\pL` syntax. It
*does* support `\p{Letter}`, but none of `re2`, `go/regexp` or `pcre2/jit`
support `\p{Letter}`.

**letters-alt**

| Parameter | Value |
| --------- | ----- |
| full name | `unicode/codepoints/letters-alt` |
| model | [`count`](MODELS.md#count) |
| regex | `````(?x)(?:
  \p{Lowercase}
  \|\p{Uppercase}
  \|\p{Titlecase_Letter}
  \|\p{Modifier_Letter}
  \|\p{Other_Letter}
){100}x````` |
| case-insensitive | `false` |
| unicode | `true` |
| haystack-path | [`unicode/allcodepoints.txt`](benchmarks/haystacks/unicode/allcodepoints.txt) |
| count | 0 |


**letters-lower-or-upper**

| Parameter | Value |
| --------- | ----- |
| full name | `unicode/codepoints/letters-lower-or-upper` |
| model | [`count`](MODELS.md#count) |
| regex | `````(?:\p{Lowercase}\|\p{Uppercase}){100}````` |
| case-insensitive | `false` |
| unicode | `true` |
| haystack-path | [`unicode/allcodepoints.txt`](benchmarks/haystacks/unicode/allcodepoints.txt) |
| count | 13 |


**contiguous-greek**

| Parameter | Value |
| --------- | ----- |
| full name | `unicode/codepoints/contiguous-greek` |
| model | [`count`](MODELS.md#count) |
| regex | `````\p{Greek}+````` |
| case-insensitive | `false` |
| unicode | `true` |
| haystack-path | [`unicode/allcodepoints.txt`](benchmarks/haystacks/unicode/allcodepoints.txt) |
| count(\*) | 36 |
| count(pcre2) | 38 |
| count(pcre2/jit) | 38 |


</details>

#### compile

| Engine | one-letter | fifty-letters | fifty-letters-ascii | match-every-line | match-every-line-ascii | negated-class-matches-codepoint |
| - | - | - | - | - | - | - |
| go/regexp | 16.39us | 14.71us | 4.90us | **818.00ns** | **809.00ns** | 504.00ns |
| hyperscan | 23.79ms | - | 465.53us | - | 129.38us | 312.66us |
| pcre2 | - | - | - | - | - | **176.00ns** |
| pcre2/jit | **2.47us** | **2.59us** | **2.15us** | 3.22us | 2.34us | 2.21us |
| python/re | - | - | - | - | - | 6.53us |
| python/regex | 20.87us | 37.29us | 63.75us | - | 41.91us | 23.88us |
| re2 | 429.32us | 11.78ms | 7.16us | 2.44us | 1.78us | 1.86us |
| regress | - | - | - | - | - | 881.00ns |
| rust/regex/dense | 10.32ms | 1.04s | 87.65us | - | - | - |
| rust/regex/meta | 133.56us | 6.35ms | 11.00us | 54.72us | 13.76us | 38.25us |
| rust/regex/nfa | 72.00us | 2.90ms | 3.58us | 10.22us | 854.00ns | 10.02us |
| rust/regexold | 145.49us | 6.03ms | 15.65us | 4.25us | 2.96us | 3.81us |

<details>
<summary>Show individual benchmark parameters.</summary>

**one-letter**

| Parameter | Value |
| --------- | ----- |
| full name | `unicode/compile/one-letter` |
| model | [`compile`](MODELS.md#compile) |
| regex | `````\pL````` |
| case-insensitive | `false` |
| unicode | `true` |
| haystack | `ͱͳͷΐάέήίΰαβγδεζηθικλμνξοπρςστυ [.. snip ..]` |
| count | 53 |


**fifty-letters**

| Parameter | Value |
| --------- | ----- |
| full name | `unicode/compile/fifty-letters` |
| model | [`compile`](MODELS.md#compile) |
| regex | `````\pL{50}````` |
| case-insensitive | `false` |
| unicode | `true` |
| haystack | `ͱͳͷΐάέήίΰαβγδεζηθικλμνξοπρςστυ [.. snip ..]` |
| count | 1 |


**fifty-letters-ascii**

| Parameter | Value |
| --------- | ----- |
| full name | `unicode/compile/fifty-letters-ascii` |
| model | [`compile`](MODELS.md#compile) |
| regex | `````[a-zA-Z]{50}````` |
| case-insensitive | `false` |
| unicode | `false` |
| haystack | `abcdefghijklmnopqrstuvwxyzabcdefghijklmnopqrstuvwxyz` |
| count(\*) | 1 |
| count(hyperscan) | 3 |


**match-every-line**

| Parameter | Value |
| --------- | ----- |
| full name | `unicode/compile/match-every-line` |
| model | [`compile`](MODELS.md#compile) |
| regex | `````(?m)^.+$````` |
| case-insensitive | `false` |
| unicode | `true` |
| haystack-path | [`lines-with-invalid-utf8.txt`](benchmarks/haystacks/lines-with-invalid-utf8.txt) |
| count(\*) | 3 |
| count(go/regexp) | 4 |


**match-every-line-ascii**

| Parameter | Value |
| --------- | ----- |
| full name | `unicode/compile/match-every-line-ascii` |
| model | [`compile`](MODELS.md#compile) |
| regex | `````(?m)^.+$````` |
| case-insensitive | `false` |
| unicode | `false` |
| haystack-path | [`lines-with-invalid-utf8.txt`](benchmarks/haystacks/lines-with-invalid-utf8.txt) |
| count | 4 |


**negated-class-matches-codepoint**

| Parameter | Value |
| --------- | ----- |
| full name | `unicode/compile/negated-class-matches-codepoint` |
| model | [`compile`](MODELS.md#compile) |
| regex | `````[^a]````` |
| case-insensitive | `false` |
| unicode | `true` |
| haystack | `☃` |
| count | 1 |


</details>

#### overlapping-words

| Engine | ascii | english | russian |
| - | - | - | - |
| go/regexp | 6.2 MB/s | 3.5 MB/s | 8.1 MB/s |
| pcre2/jit | **95.3 MB/s** | **48.8 MB/s** | **72.6 MB/s** |
| python/regex | 4.4 MB/s | 5.2 MB/s | 11.5 MB/s |
| re2 | 50.5 MB/s | 956.4 KB/s | 788.5 KB/s |
| regress | 27.6 MB/s | - | - |
| rust/regex | 46.1 MB/s | 45.4 MB/s | 18.8 MB/s |
| rust/regex/meta | 68.4 MB/s | 6.2 MB/s | 5.7 MB/s |
| rust/regexold | 47.2 MB/s | 141.7 KB/s | 271.4 KB/s |

<details>
<summary>Show individual benchmark parameters.</summary>

**ascii**

| Parameter | Value |
| --------- | ----- |
| full name | `unicode/overlapping-words/ascii` |
| model | [`grep-captures`](MODELS.md#grep-captures) |
| regex | `````([A-Za-z]{14})\|([A-Za-z]{13})\|([A-Za-z]{12})\|([A-Za-z]{11})\|([A-Za-z]{10})\|([A-Za-z]{9})\|([A-Za-z]{8})\|([A-Za-z]{7})\|([A-Za-z]{6})\|([A-Za-z]{5})````` |
| case-insensitive | `false` |
| unicode | `false` |
| haystack-path | [`opensubtitles/en-medium.txt`](benchmarks/haystacks/opensubtitles/en-medium.txt) |
| count | 6156 |


**english**

| Parameter | Value |
| --------- | ----- |
| full name | `unicode/overlapping-words/english` |
| model | [`grep-captures`](MODELS.md#grep-captures) |
| regex | `````(\pL{14})\|(\pL{13})\|(\pL{12})\|(\pL{11})\|(\pL{10})\|(\pL{9})\|(\pL{8})\|(\pL{7})\|(\pL{6})\|(\pL{5})````` |
| case-insensitive | `false` |
| unicode | `true` |
| haystack-path | [`opensubtitles/en-medium.txt`](benchmarks/haystacks/opensubtitles/en-medium.txt) |
| count | 6156 |


**russian**

| Parameter | Value |
| --------- | ----- |
| full name | `unicode/overlapping-words/russian` |
| model | [`grep-captures`](MODELS.md#grep-captures) |
| regex | `````(\pL{14})\|(\pL{13})\|(\pL{12})\|(\pL{11})\|(\pL{10})\|(\pL{9})\|(\pL{8})\|(\pL{7})\|(\pL{6})\|(\pL{5})````` |
| case-insensitive | `false` |
| unicode | `true` |
| haystack-path | [`opensubtitles/ru-medium.txt`](benchmarks/haystacks/opensubtitles/ru-medium.txt) |
| count | 5710 |


</details>

#### word

| Engine | boundary-any-english | boundary-any-russian | boundary-long-english | boundary-long-russian | around-holmes-english | around-holmes-russian |
| - | - | - | - | - | - | - |
| go/regexp | 15.2 MB/s | - | 45.3 MB/s | - | 30.5 MB/s | - |
| hyperscan | 155.6 MB/s | - | 439.8 MB/s | - | - | - |
| pcre2 | 96.2 MB/s | - | 69.7 MB/s | - | 50.7 MB/s | - |
| pcre2/jit | **199.0 MB/s** | **228.5 MB/s** | 246.8 MB/s | **195.7 MB/s** | 326.8 MB/s | **319.7 MB/s** |
| python/re | 32.5 MB/s | - | 100.9 MB/s | - | 65.1 MB/s | - |
| python/regex | 28.2 MB/s | 45.1 MB/s | 51.3 MB/s | 103.2 MB/s | 34.6 MB/s | 70.3 MB/s |
| re2 | 63.1 MB/s | - | **952.6 MB/s** | - | 989.0 MB/s | - |
| regress | 166.7 MB/s | - | 153.1 MB/s | - | 84.2 MB/s | - |
| rust/regex/meta | 109.7 MB/s | 18.6 MB/s | 812.7 MB/s | 30.5 MB/s | **52.4 GB/s** | 26.6 MB/s |

<details>
<summary>Show individual benchmark parameters.</summary>

**boundary-any-english**

| Parameter | Value |
| --------- | ----- |
| full name | `unicode/word/boundary-any-english` |
| model | [`count-spans`](MODELS.md#count-spans) |
| regex | `````\b\w+\b````` |
| case-insensitive | `false` |
| unicode | `false` |
| haystack-path | [`opensubtitles/en-huge.txt`](benchmarks/haystacks/opensubtitles/en-huge.txt) |
| count | 450561 |


**boundary-any-russian**

| Parameter | Value |
| --------- | ----- |
| full name | `unicode/word/boundary-any-russian` |
| model | [`count-spans`](MODELS.md#count-spans) |
| regex | `````\b\w+\b````` |
| case-insensitive | `false` |
| unicode | `true` |
| haystack-path | [`opensubtitles/ru-huge.txt`](benchmarks/haystacks/opensubtitles/ru-huge.txt) |
| count | 529194 |


**boundary-long-english**

| Parameter | Value |
| --------- | ----- |
| full name | `unicode/word/boundary-long-english` |
| model | [`count-spans`](MODELS.md#count-spans) |
| regex | `````\b\w{12,}\b````` |
| case-insensitive | `false` |
| unicode | `false` |
| haystack-path | [`opensubtitles/en-huge.txt`](benchmarks/haystacks/opensubtitles/en-huge.txt) |
| count | 3466 |


**boundary-long-russian**

| Parameter | Value |
| --------- | ----- |
| full name | `unicode/word/boundary-long-russian` |
| model | [`count-spans`](MODELS.md#count-spans) |
| regex | `````\b\w{12,}\b````` |
| case-insensitive | `false` |
| unicode | `true` |
| haystack-path | [`opensubtitles/ru-huge.txt`](benchmarks/haystacks/opensubtitles/ru-huge.txt) |
| count | 21332 |


**around-holmes-english**

| Parameter | Value |
| --------- | ----- |
| full name | `unicode/word/around-holmes-english` |
| model | [`count-spans`](MODELS.md#count-spans) |
| regex | `````\b\w+\s+Holmes\s+\w+\b````` |
| case-insensitive | `false` |
| unicode | `false` |
| haystack-path | [`opensubtitles/en-huge.txt`](benchmarks/haystacks/opensubtitles/en-huge.txt) |
| count | 27 |


**around-holmes-russian**

| Parameter | Value |
| --------- | ----- |
| full name | `unicode/word/around-holmes-russian` |
| model | [`count-spans`](MODELS.md#count-spans) |
| regex | `````\b\w+\s+Холмс\s+\w+\b````` |
| case-insensitive | `false` |
| unicode | `true` |
| haystack-path | [`opensubtitles/ru-huge.txt`](benchmarks/haystacks/opensubtitles/ru-huge.txt) |
| count | 44 |


</details>

### wild

#### bibleref

| Engine | compile | long | short | line |
| - | - | - | - | - |
| go/regexp | 38.32us | 10.9 MB/s | 22.0 MB/s | 13.4 MB/s |
| pcre2/jit | 22.18us | 77.4 MB/s | **220.5 MB/s** | 73.6 MB/s |
| python/regex | 381.08us | 4.5 MB/s | 8.9 MB/s | 4.4 MB/s |
| re2 | 401.81us | 774.5 MB/s | 9.4 MB/s | 414.9 MB/s |
| rust/regex/ast | **8.86us** | - | - | - |
| rust/regex/hir | 11.62us | - | - | - |
| rust/regex/meta | 318.36us | **791.5 MB/s** | 55.4 MB/s | **584.9 MB/s** |
| rust/regex/nfa | 108.39us | - | - | - |
| rust/regexold | 253.61us | 650.2 MB/s | 45.2 MB/s | 531.8 MB/s |

<details>
<summary>Show individual benchmark parameters.</summary>

**compile**

| Parameter | Value |
| --------- | ----- |
| full name | `wild/bibleref/compile` |
| model | [`compile`](MODELS.md#compile) |
| regex-path | [`wild/bibleref.txt`](benchmarks/regexes/wild/bibleref.txt) |
| case-insensitive | `false` |
| unicode | `true` |
| haystack | `Gen 1:1, 2
3 King 1:3-4
II Ki. 3:12-14, 25
` |
| count | 3 |


**long**

| Parameter | Value |
| --------- | ----- |
| full name | `wild/bibleref/long` |
| model | [`count-captures`](MODELS.md#count-captures) |
| regex-path | [`wild/bibleref.txt`](benchmarks/regexes/wild/bibleref.txt) |
| case-insensitive | `false` |
| unicode | `true` |
| haystack-path | [`opensubtitles/en-huge.txt`](benchmarks/haystacks/opensubtitles/en-huge.txt) |
| count | 874 |


**short**

| Parameter | Value |
| --------- | ----- |
| full name | `wild/bibleref/short` |
| model | [`count-captures`](MODELS.md#count-captures) |
| regex-path | [`wild/bibleref.txt`](benchmarks/regexes/wild/bibleref.txt) |
| case-insensitive | `false` |
| unicode | `true` |
| haystack | `Gen 1:1, 2
3 King 1:3-4
II Ki. 3:12-14, 25
` |
| count | 30 |


**line**

| Parameter | Value |
| --------- | ----- |
| full name | `wild/bibleref/line` |
| model | [`grep-captures`](MODELS.md#grep-captures) |
| regex-path | [`wild/bibleref.txt`](benchmarks/regexes/wild/bibleref.txt) |
| case-insensitive | `false` |
| unicode | `true` |
| haystack-path | [`opensubtitles/en-huge.txt`](benchmarks/haystacks/opensubtitles/en-huge.txt) |
| count | 874 |


</details>

#### caddy

| Engine | caddy |
| - | - |
| go/regexp | 125.4 MB/s |
| pcre2 | 466.0 MB/s |
| pcre2/jit | **1645.9 MB/s** |
| python/re | 131.8 MB/s |
| python/regex | 100.0 MB/s |
| re2 | 145.6 MB/s |
| regress | 485.9 MB/s |
| rust/regex | 110.9 MB/s |
| rust/regex/meta | 391.0 MB/s |
| rust/regexold | 113.0 MB/s |

<details>
<summary>Show individual benchmark parameters.</summary>

**caddy**

| Parameter | Value |
| --------- | ----- |
| full name | `wild/caddy/caddy` |
| model | [`count-captures`](MODELS.md#count-captures) |
| regex | `````^([0-9]{4}-[0-9]{2}-[0-9]{2}T[0-9]{2}:[0-9]{2}:[0-9]{2}Z)\t(\w+)\t(\w+)\t([^\t]+)(?:\t(.+))?$````` |
| case-insensitive | `false` |
| unicode | `false` |
| haystack | `2022-07-27T00:18:48Z	info	tls	cleaning storage unit	{"descri [.. snip ..]` |
| count | 6 |


</details>

#### dot-star-capture

| Engine | rust-src-tools |
| - | - |
| go/regexp | 19.7 MB/s |
| pcre2 | 67425.3 GB/s |
| pcre2/jit | **191038.3 GB/s** |
| python/re | 10830.5 GB/s |
| re2 | 18.0 MB/s |
| rust/regex/meta | 466.7 MB/s |

<details>
<summary>Show individual benchmark parameters.</summary>

**rust-src-tools**

| Parameter | Value |
| --------- | ----- |
| full name | `wild/dot-star-capture/rust-src-tools` |
| model | [`count-captures`](MODELS.md#count-captures) |
| regex | `````(?s)^((.*)()()($))````` |
| case-insensitive | `false` |
| unicode | `false` |
| haystack-path | [`rust-src-tools-3b0d4813.txt`](benchmarks/haystacks/rust-src-tools-3b0d4813.txt) |
| count | 6 |


</details>

#### grapheme

| Engine | compile | source-code | codepoints |
| - | - | - | - |
| python/regex | 438.12us | 4.0 MB/s | 14.6 MB/s |
| rust/regex/ast | **10.57us** | - | - |
| rust/regex/dense | 34.55ms | 73.7 MB/s | 218.1 MB/s |
| rust/regex/hir | 15.96us | - | - |
| rust/regex/hybrid | - | 40.6 MB/s | 134.7 MB/s |
| rust/regex/meta | 350.25us | **95.2 MB/s** | **340.4 MB/s** |
| rust/regex/nfa | 149.53us | - | - |
| rust/regex/pikevm | - | - | 6.4 MB/s |
| rust/regexold | 334.56us | 47.4 MB/s | 172.1 MB/s |

<details>
<summary>Show individual benchmark parameters.</summary>

**compile**

| Parameter | Value |
| --------- | ----- |
| full name | `wild/grapheme/compile` |
| model | [`compile`](MODELS.md#compile) |
| regex-path | [`wild/grapheme.txt`](benchmarks/regexes/wild/grapheme.txt) |
| case-insensitive | `false` |
| unicode | `true` |
| haystack | `à̖🇺🇸` |
| count | 2 |


**source-code**

| Parameter | Value |
| --------- | ----- |
| full name | `wild/grapheme/source-code` |
| model | [`count`](MODELS.md#count) |
| regex-path | [`wild/grapheme.txt`](benchmarks/regexes/wild/grapheme.txt) |
| case-insensitive | `false` |
| unicode | `true` |
| haystack-path | [`rust-src-tools-3b0d4813.txt`](benchmarks/haystacks/rust-src-tools-3b0d4813.txt) |
| count(\*) | 7382210 |
| count(python/regex) | 6832947 |


**codepoints**

| Parameter | Value |
| --------- | ----- |
| full name | `wild/grapheme/codepoints` |
| model | [`count`](MODELS.md#count) |
| regex-path | [`wild/grapheme.txt`](benchmarks/regexes/wild/grapheme.txt) |
| case-insensitive | `false` |
| unicode | `true` |
| haystack-path | [`unicode/allcodepoints.txt`](benchmarks/haystacks/unicode/allcodepoints.txt) |
| count | 1109158 |


</details>

#### parol-veryl

| Engine | ascii | unicode | multi-patternid-ascii | multi-captures-ascii |
| - | - | - | - | - |
| rust/regex/dense | - | - | **92.7 MB/s** | - |
| rust/regex/meta | **9.2 MB/s** | **7.7 MB/s** | 62.7 MB/s | **29.1 MB/s** |
| rust/regexold | 238.0 KB/s | 218.5 KB/s | - | - |

<details>
<summary>Show individual benchmark parameters.</summary>

**ascii**

| Parameter | Value |
| --------- | ----- |
| full name | `wild/parol-veryl/ascii` |
| model | [`count-captures`](MODELS.md#count-captures) |
| regex-path | [`wild/parol-veryl.txt`](benchmarks/regexes/wild/parol-veryl.txt) |
| case-insensitive | `false` |
| unicode | `false` |
| haystack-path | [`wild/parol-veryl.vl`](benchmarks/haystacks/wild/parol-veryl.vl) |
| count | 124800 |


**unicode**

| Parameter | Value |
| --------- | ----- |
| full name | `wild/parol-veryl/unicode` |
| model | [`count-captures`](MODELS.md#count-captures) |
| regex-path | [`wild/parol-veryl.txt`](benchmarks/regexes/wild/parol-veryl.txt) |
| case-insensitive | `false` |
| unicode | `true` |
| haystack-path | [`wild/parol-veryl.vl`](benchmarks/haystacks/wild/parol-veryl.vl) |
| count | 124800 |


**multi-patternid-ascii**

| Parameter | Value |
| --------- | ----- |
| full name | `wild/parol-veryl/multi-patternid-ascii` |
| model | [`count-spans`](MODELS.md#count-spans) |
| regex-path | [`wild/parol-veryl.txt`](benchmarks/regexes/wild/parol-veryl.txt) |
| case-insensitive | `false` |
| unicode | `false` |
| haystack-path | [`wild/parol-veryl.vl`](benchmarks/haystacks/wild/parol-veryl.vl) |
| count | 150600 |


**multi-captures-ascii**

| Parameter | Value |
| --------- | ----- |
| full name | `wild/parol-veryl/multi-captures-ascii` |
| model | [`count-captures`](MODELS.md#count-captures) |
| regex-path | [`wild/parol-veryl.txt`](benchmarks/regexes/wild/parol-veryl.txt) |
| case-insensitive | `false` |
| unicode | `false` |
| haystack-path | [`wild/parol-veryl.vl`](benchmarks/haystacks/wild/parol-veryl.vl) |
| count | 124800 |


</details>

#### ruff

| Engine | whitespace-around-keywords | noqa | unnecessary-coding-comment | string-quote-prefix | space-around-operator | shebang |
| - | - | - | - | - | - | - |
| pcre2/jit | 105.6 MB/s | 313.6 MB/s | **1650.3 MB/s** | 1844.6 MB/s | 181.6 MB/s | **1615.9 MB/s** |
| re2 | - | 536.8 MB/s | 773.9 MB/s | 658.6 MB/s | 320.1 MB/s | 855.9 MB/s |
| rust/regex | 184.3 MB/s | 735.5 MB/s | 1270.8 MB/s | 873.0 MB/s | 331.8 MB/s | 263.1 MB/s |
| rust/regex/meta | **298.3 MB/s** | **1669.8 MB/s** | 1246.3 MB/s | **1926.0 MB/s** | **415.3 MB/s** | 966.9 MB/s |
| rust/regexold | 189.2 MB/s | 738.5 MB/s | 1288.8 MB/s | 880.4 MB/s | 330.8 MB/s | 267.2 MB/s |

<details>
<summary>Show individual benchmark parameters.</summary>

**whitespace-around-keywords**

| Parameter | Value |
| --------- | ----- |
| full name | `wild/ruff/whitespace-around-keywords` |
| model | [`grep-captures`](MODELS.md#grep-captures) |
| regex | `````(\s*)\b(?:False\|None\|True\|and\|as\|assert\|async\|await\|break\|class\|continue\|def\|del\|elif\|else\|except\|finally\|for\|from\|global\|if\|import\|in\|is\|lambda\|nonlocal\|not\|or\|pass\|raise\|return\|try\|while\|with\|yield)\b(\s*)````` |
| case-insensitive | `false` |
| unicode | `true` |
| haystack-path | [`wild/cpython-226484e4.py`](benchmarks/haystacks/wild/cpython-226484e4.py) |
| count | 1312482 |


**noqa**

| Parameter | Value |
| --------- | ----- |
| full name | `wild/ruff/noqa` |
| model | [`grep-captures`](MODELS.md#grep-captures) |
| regex | `````(?P<spaces>\s*)(?P<noqa>(?i:# noqa)(?::\s?(?P<codes>([A-Z]+[0-9]+(?:[,\s]+)?)+))?)````` |
| case-insensitive | `false` |
| unicode | `true` |
| haystack-path | [`wild/cpython-226484e4.py`](benchmarks/haystacks/wild/cpython-226484e4.py) |
| count | 84 |


**unnecessary-coding-comment**

| Parameter | Value |
| --------- | ----- |
| full name | `wild/ruff/unnecessary-coding-comment` |
| model | [`grep`](MODELS.md#grep) |
| regex | `````^[ \t\f]*#.*?coding[:=][ \t]*utf-?8````` |
| case-insensitive | `false` |
| unicode | `true` |
| haystack-path | [`wild/cpython-226484e4.py`](benchmarks/haystacks/wild/cpython-226484e4.py) |
| count | 16 |


**string-quote-prefix**

| Parameter | Value |
| --------- | ----- |
| full name | `wild/ruff/string-quote-prefix` |
| model | [`grep-captures`](MODELS.md#grep-captures) |
| regex | `````^(?i)[urb]*['"](?P<raw>.*)['"]$````` |
| case-insensitive | `false` |
| unicode | `true` |
| haystack-path | [`wild/cpython-226484e4.py`](benchmarks/haystacks/wild/cpython-226484e4.py) |
| count | 2972 |


**space-around-operator**

| Parameter | Value |
| --------- | ----- |
| full name | `wild/ruff/space-around-operator` |
| model | [`grep-captures`](MODELS.md#grep-captures) |
| regex | `````[^,\s](\s*)(?:[-+*/\|!<=>%&^]+\|:=)(\s*)````` |
| case-insensitive | `false` |
| unicode | `true` |
| haystack-path | [`wild/cpython-226484e4.py`](benchmarks/haystacks/wild/cpython-226484e4.py) |
| count | 1224378 |


**shebang**

| Parameter | Value |
| --------- | ----- |
| full name | `wild/ruff/shebang` |
| model | [`grep-captures`](MODELS.md#grep-captures) |
| regex | `````^(?P<spaces>\s*)#!(?P<directive>.*)````` |
| case-insensitive | `false` |
| unicode | `true` |
| haystack-path | [`wild/cpython-226484e4.py`](benchmarks/haystacks/wild/cpython-226484e4.py) |
| count | 282 |


</details>

#### rustsec-cargo-audit

This group of benchmarks comes from the `cargo audit` tool out of the [rustsec]
project. It was [reported by Shnatsel][shnatsel-report] to the Rust regex
crate.

This regex attempts to extract dependencies and their versions from a
compiled Rust program. The actual issue reported here was that Shnatsel, for
performance, split the regex into a Unix and Windows version, and runs them
separately. The reason for this was that combining them into one regex was
slower. Indeed, when they're combined (and we measure two differents ways
of doing that below), the heuristics in the old regex crate wind up doing a
multiple substring search instead of a search for `cargo`, which is a common
prefix. This slows things down quite a bit.

[rustsec]: https://github.com/rustsec/rustsec
[shnatsel-report]: https://github.com/rust-lang/regex/discussions/960#discussioncomment-5099839
[rustsec-dep-regex]: https://github.com/rustsec/rustsec/blob/26a04a409da94c30b67f45878461998df68d4108/quitters/src/lib.rs#L28-L29

| Engine | original-unix | original-windows | both-slashes | both-alternate |
| - | - | - | - | - |
| go/regexp | 10.0 GB/s | 9.4 GB/s | 9.6 GB/s | 10.0 GB/s |
| pcre2 | 13.7 GB/s | 14.4 GB/s | 13.8 GB/s | 12.6 GB/s |
| pcre2/jit | **34.0 GB/s** | **36.4 GB/s** | **41.3 GB/s** | **41.4 GB/s** |
| python/re | 4.2 GB/s | 4.2 GB/s | 4.2 GB/s | 4.2 GB/s |
| python/regex | 7.1 GB/s | 6.9 GB/s | 2.1 GB/s | 2.1 GB/s |
| re2 | 20.9 GB/s | 20.5 GB/s | 20.5 GB/s | 20.8 GB/s |
| rust/regex | 8.9 GB/s | 8.7 GB/s | 7.6 GB/s | 6.9 GB/s |
| rust/regex/meta | 24.9 GB/s | 23.2 GB/s | 26.9 GB/s | 26.8 GB/s |
| rust/regexold | 9.4 GB/s | 8.8 GB/s | 5.2 GB/s | 4.8 GB/s |

<details>
<summary>Show individual benchmark parameters.</summary>

**original-unix**

| Parameter | Value |
| --------- | ----- |
| full name | `wild/rustsec-cargo-audit/original-unix` |
| model | [`count-captures`](MODELS.md#count-captures) |
| regex | `````cargo/registry/src/[^/]+/([0-9A-Za-z_-]+)-([0-9]+\.[0-9]+\.[0-9]+[0-9A-Za-z+.-]*)/````` |
| case-insensitive | `false` |
| unicode | `false` |
| haystack-path | [`wild/rg-13.0.0-x86_64-unknown-linux-musl.bin`](benchmarks/haystacks/wild/rg-13.0.0-x86_64-unknown-linux-musl.bin) |
| count | 471 |


**original-windows**

| Parameter | Value |
| --------- | ----- |
| full name | `wild/rustsec-cargo-audit/original-windows` |
| model | [`count-captures`](MODELS.md#count-captures) |
| regex | `````cargo\\registry\\src\\[^\\]+\\([0-9A-Za-z_-]+)-([0-9]+\.[0-9]+\.[0-9]+[0-9A-Za-z+.-]*)\\````` |
| case-insensitive | `false` |
| unicode | `false` |
| haystack-path | [`wild/rg-13.0.0-x86_64-pc-windows-msvc.bin`](benchmarks/haystacks/wild/rg-13.0.0-x86_64-pc-windows-msvc.bin) |
| count | 462 |


**both-slashes**

| Parameter | Value |
| --------- | ----- |
| full name | `wild/rustsec-cargo-audit/both-slashes` |
| model | [`count-captures`](MODELS.md#count-captures) |
| regex | `````cargo[\\/]registry[\\/]src[\\/][^\\/]+[\\/]([0-9A-Za-z_-]+)-([0-9]+\.[0-9]+\.[0-9]+[0-9A-Za-z+.-]*)[\\/]````` |
| case-insensitive | `false` |
| unicode | `false` |
| haystack-path | [`wild/rg-13.0.0-x86_64-unknown-linux-musl.bin`](benchmarks/haystacks/wild/rg-13.0.0-x86_64-unknown-linux-musl.bin) |
| count | 471 |


**both-alternate**

| Parameter | Value |
| --------- | ----- |
| full name | `wild/rustsec-cargo-audit/both-alternate` |
| model | [`count-captures`](MODELS.md#count-captures) |
| regex | `````cargo/registry/src/[^/]+/([0-9A-Za-z_-]+)-([0-9]+\.[0-9]+\.[0-9]+[0-9A-Za-z+.-]*)/\|cargo\\registry\\src\\[^\\]+\\([0-9A-Za-z_-]+)-([0-9]+\.[0-9]+\.[0-9]+[0-9A-Za-z+.-]*)\\````` |
| case-insensitive | `false` |
| unicode | `false` |
| haystack-path | [`wild/rg-13.0.0-x86_64-unknown-linux-musl.bin`](benchmarks/haystacks/wild/rg-13.0.0-x86_64-unknown-linux-musl.bin) |
| count | 471 |


</details>

#### url

| Engine | compile | search |
| - | - | - |
| go/regexp | 5.41ms | 3.1 MB/s |
| hyperscan | 328.67ms | - |
| pcre2 | **194.71us** | 2.9 MB/s |
| pcre2/jit | 942.90us | 20.4 MB/s |
| python/re | 7.22ms | 3.5 MB/s |
| python/regex | 22.22ms | 1537.6 KB/s |
| re2 | 2.18ms | **113.8 MB/s** |
| rust/regex/meta | 3.46ms | 101.4 MB/s |

<details>
<summary>Show individual benchmark parameters.</summary>

**compile**

| Parameter | Value |
| --------- | ----- |
| full name | `wild/url/compile` |
| model | [`compile`](MODELS.md#compile) |
| regex-path | [`wild/url.txt`](benchmarks/regexes/wild/url.txt) |
| case-insensitive | `true` |
| unicode | `false` |
| haystack | `https://google.com` |
| count(\*) | 1 |
| count(hyperscan) | 2 |


**search**

| Parameter | Value |
| --------- | ----- |
| full name | `wild/url/search` |
| model | [`count-spans`](MODELS.md#count-spans) |
| regex-path | [`wild/url.txt`](benchmarks/regexes/wild/url.txt) |
| case-insensitive | `true` |
| unicode | `false` |
| haystack-path | [`rust-src-tools-3b0d4813.txt`](benchmarks/haystacks/rust-src-tools-3b0d4813.txt) |
| count | 234965 |


</details>

<!-- END: report -->

## Wanted

It would be great to add more regex engines to this barometer. I am thinking
of at least the following, but I'm generally open to any regex engine that
has a reasonable build process with stable tooling:

* Perl's regex engine.
* Ruby's regex engine, or perhaps just [Onigmo](https://github.com/k-takata/Onigmo)
directly.
* [ICU's regex engine](https://unicode-org.github.io/icu/userguide/strings/regexp.html)
* [`nim-regex`](https://github.com/nitely/nim-regex)
* [D's std.regex](https://dlang.org/phobos/std_regex.html)
* [CTRE](https://github.com/hanickadot/compile-time-regular-expressions). (This
one may prove tricky since "compile a regex" probably means "compile a C++
program." The rebar tool supports this, but it will be annoying. If you want
to add this, please file an issue to discuss an implementation path.)
* A POSIX regex engine.
* Javascript's regex engine. (Is it accessible outside of a browser?)
* [`java.util.regex`](https://docs.oracle.com/javase/8/docs/api/java/util/regex/Pattern.html)
* [`System.Text.RegularExpressions`](https://learn.microsoft.com/en-us/dotnet/api/system.text.regularexpressions.regex?view=net-7.0) from `.NET`.
* [`NSRegularExpression`](https://developer.apple.com/documentation/foundation/nsregularexpression), perhaps through Swift?
* Lisp's [CL-PPCRE](https://github.com/edicl/cl-ppcre/).
* A selected subset of the [mess that is regex libraries for Haskell](https://wiki.haskell.org/Regular_expressions).

Here are some other regex engines I'm aware of, but I have reservations about
including them:

* PHP's `preg` functions. This "just" uses PCRE2, which is already included
in this benchmark, so it's not clear whether it's also worth measuring here
too. But maybe it is. Maybe PHP introduces some interesting performance
characteristics that meaningfully alter the picture presented by using PCRE2
directly.
* Julia's standard regex engine, which last I checked was also PCRE2. So a
similar reasoning as for PHP applies here.
* C++'s `std::regex` or Boost's regex engine. These are known to be horribly
slow. Maybe we should still include them for completeness.
* [re2c](http://re2c.org/) does regex matching through code generation, so this
would likely work similarly to CTRE if it were to be added. It serves a very
different use case than most regex engines, so I'm not sure if it fits here,
but it could be interesting.
* Regex engines embedded in grep tools like GNU grep. These may be a little
tricky to correctly benchmark given the methodology here, but I think it
should be possible to satisfy at least some of the models. The idea here would
be to actually call the `grep` program and not try to rip the regex engine
out of it.
* Tcl's regex library is something I've benchmarked in the past and I recall
it also being extraordinarily slow. So I'm not sure if it's worth it? Also,
does anyone still use Tcl?

I think the main criteria for inclusion are:

* Someone has to actually be using the regex engine for something. It's not
scalable to include every regex engine someone threw up on GitHub five years
ago that isn't being maintained and nobody is using.
* The build process for the regex engine needs to be somewhat reasonable, or it
needs to somehow be maintained by someone else. For example, we don't build
Python's regex engine. Instead, we just require that Python be installed.
